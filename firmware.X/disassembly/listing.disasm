Disassembly Listing for firmware_dev
Generated From:
/firmware.X/dist/default/production/firmware.X.production.elf
Jul 11, 2018 12:09:26 AM

---  /firmware.X/main.c  --------------------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            /*
18:             * File:   main.c
19:             * Author: David
20:             *
21:             * Created on May 15, 2018, 3:16 AM
22:             */
23:            
24:            // CONFIG
25:            #pragma config FOSC = XT        // Oscillator Selection bits (XT oscillator)
26:            #pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT enabled)
27:            #pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
28:            #pragma config BOREN = OFF      // Brown-out Reset Enable bit (BOR disabled)
29:            #pragma config BODENV = 40      // Brown-out Reset Voltage bit (VBOR set to 4.0V)
30:            #pragma config CP = OFF         // Code Protect (Program memory code protection is disabled)
31:            
32:            #include <xc.h>
33:            
34:            #include "ir_decoder.h"
35:            #include "ir_transmitter.h"
36:            #include "leds.h"
37:            
38:            volatile uint8_t move_leds = 1;
39:            // Transmitting or receiving?
40:            volatile uint8_t ir_transmitting = 0;
41:            
42:            static void interrupt ISR(void) {
0004  00FE     MOVWF 0x7E
43:                if (INTCONbits.T0IF) {
0196  1D0B     BTFSS INTCON, 0x2
0197  299E     GOTO 0x19E
44:                    if (move_leds)
0198  0839     MOVF move_leds, W
0199  1903     BTFSC STATUS, 0x2
019A  299D     GOTO 0x19D
45:                        timer0_interrupt();
019B  21F5     CALL 0x1F5
019C  299E     GOTO 0x19E
46:                    else
47:                        INTCONbits.T0IF = 0;
019D  110B     BCF INTCON, 0x2
48:                }
49:                if (PIR1bits.TMR1IF) {
019E  1283     BCF STATUS, 0x5
019F  1C0C     BTFSS PIR1, 0x0
01A0  29B0     GOTO 0x1B0
50:                    if (!ir_transmitting) {
01A1  0833     MOVF ir_transmitting, W
01A2  1D03     BTFSS STATUS, 0x2
01A3  29AF     GOTO 0x1AF
51:                        timer1_interrupt_decoder();
01A4  2021     CALL 0x21
52:                        if (ir_data_valid) {
01A5  1283     BCF STATUS, 0x5
01A6  0837     MOVF ir_data_valid, W
01A7  1903     BTFSC STATUS, 0x2
01A8  29B0     GOTO 0x1B0
53:                            move_leds ^= 1;
01A9  3001     MOVLW 0x1
01AA  00F9     MOVWF 0x79
01AB  0879     MOVF 0x79, W
01AC  06B9     XORWF move_leds, F
54:                            ir_data_valid = 0;
01AD  01B7     CLRF ir_data_valid
55:                        }
56:                    } else {
01AE  29B0     GOTO 0x1B0
57:                        PIR1bits.TMR1IF = 0;
01AF  100C     BCF PIR1, 0x0
58:                    }
59:                }
60:            }
01B0  087D     MOVF 0x7D, W
01B1  00FF     MOVWF 0x7F
01B2  087C     MOVF 0x7C, W
01B3  008A     MOVWF PCLATH
01B4  087B     MOVF 0x7B, W
01B5  0084     MOVWF FSR
01B6  0E7A     SWAPF 0x7A, W
01B7  0083     MOVWF STATUS
01B8  0EFE     SWAPF 0x7E, F
01B9  0E7E     SWAPF 0x7E, W
01BA  0009     RETFIE
61:            
62:            void main(void) {
63:                timer0_setup();
0202  220D     CALL 0x20D
64:                setup_ir_decoder();
0203  21D1     CALL 0x1D1
65:                setup_ir_transmitter();
0204  2227     CALL 0x227
66:                
67:                while (1){
020C  2A05     GOTO 0x205
68:                    transmit_word(0x55,0x55);
0205  3055     MOVLW 0x55
0206  1283     BCF STATUS, 0x5
0207  00AC     MOVWF 0x2C
0208  082C     MOVF 0x2C, W
0209  00A5     MOVWF command
020A  3055     MOVLW 0x55
020B  215D     CALL 0x15D
020C  2A05     GOTO 0x205
69:                    //service_leds();
70:                }
71:            }
---  /firmware.X/leds.c  --------------------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            #include <stdint.h>
18:            
19:            #include <xc.h>
20:            
21:            #include "leds.h"
22:            
23:            volatile uint16_t led_pos = 0;
24:            volatile uint8_t led_mode = LMODE_BLUE_TEAM; // default mode
25:            
26:            #define LED_RED_LEFT()          leda_on(0, 0)
27:            #define LED_RED_RIGHT()         leda_on(0, 1)
28:            #define LED_YELLOW_LEFT()       leda_on(2, 0)
29:            #define LED_YELLOW_RIGHT()      leda_on(2, 1)
30:            #define LED_GREEN_LEFT()        ledb_on(3, 0)
31:            #define LED_GREEN_RIGHT()       leda_on(3, 0)
32:            #define LED_BLUE_LEFT()         ledb_on(3, 1)
33:            #define LED_BLUE_RIGHT()        leda_on(3, 1)
34:            
35:            static inline void all_off();
36:            static inline void leda_on(uint8_t pos, uint8_t dir);
37:            static inline void ledb_on(uint8_t pos, uint8_t dir);
38:            
39:            /*
40:             * Turn on exactly one LED
41:             */
42:            void exactly_on(uint8_t which) {
43:                all_off();
44:                switch (which) {
45:                    case 0:
46:                        LED_RED_LEFT();
47:                        break;
48:                    case 1:
49:                        LED_YELLOW_LEFT();
50:                        break;
51:                    case 2:
52:                        LED_GREEN_LEFT();
53:                        break;
54:                    case 3:
55:                        LED_BLUE_LEFT();
56:                        break;
57:                    case 4:
58:                        LED_RED_RIGHT();
59:                        break;
60:                    case 5:
61:                        LED_YELLOW_RIGHT();
62:                        break;
63:                    case 6:
64:                        LED_GREEN_RIGHT();
65:                        break;
66:                    case 7:
67:                        LED_BLUE_RIGHT();
68:                        break;
69:                }
70:            }
71:            
72:            /*
73:             * Turn all LEDs off
74:             */
75:            static inline void all_off() {
76:                TRISA |= 1 | (1 << 2) | (1 << 3);
77:                TRISB |= (1 << 3);
78:            }
79:            
80:            /*
81:             * Turn a LED on on PORTA
82:             */
83:            static inline void leda_on(uint8_t pos, uint8_t dir) {
84:                if (dir)
85:                    PORTA |= (1u<<pos);
86:                else
87:                    PORTA &= ~(1u<<pos);
88:                TRISA &= ~(1u<<pos);
89:            }
90:            
91:            /*
92:             * Turn a LED on on PORTB
93:             */
94:            static inline void ledb_on(uint8_t pos, uint8_t dir) {
95:                if (dir)
96:                    PORTB |= (1u<<pos);
97:                else
98:                    PORTB &= ~(1u<<pos);
99:                TRISB &= ~(1u<<pos);
100:           }
101:           
102:           void timer0_interrupt(void) {
103:               led_pos++;
01F5  3001     MOVLW 0x1
01F6  1283     BCF STATUS, 0x5
01F7  07B1     ADDWF led_pos, F
01F8  1803     BTFSC STATUS, 0x0
01F9  0AB2     INCF 0x32, F
01FA  3000     MOVLW 0x0
01FB  07B2     ADDWF 0x32, F
104:               led_pos &= 0b1111111111;
01FC  30FF     MOVLW 0xFF
01FD  05B1     ANDWF led_pos, F
01FE  3003     MOVLW 0x3
01FF  05B2     ANDWF 0x32, F
105:               INTCONbits.T0IF = 0;  // Clear flag
0200  110B     BCF INTCON, 0x2
106:           }
0201  0008     RETURN
107:           
108:           void bits3_chase(uint8_t pos) {
109:               switch (pos) {
110:                default:
111:                case 0:
112:                    LED_RED_LEFT();
113:                    break;
114:                case 1:
115:                    LED_YELLOW_LEFT();
116:                    break;
117:                case 2:
118:                    LED_GREEN_LEFT();
119:                    break;
120:                case 3:
121:                    LED_BLUE_LEFT();
122:                    break;
123:                case 4:
124:                    LED_RED_RIGHT();
125:                    break;
126:                case 5:
127:                    LED_YELLOW_RIGHT();
128:                    break;
129:                case 6:
130:                    LED_GREEN_RIGHT();
131:                    break;
132:                case 7:
133:                    LED_BLUE_RIGHT();
134:                    break;
135:               }
136:           }
137:           
138:           void bits2_double_chase(uint8_t pos, uint8_t side) {
139:               switch (pos) {
140:                default:
141:                case 0:
142:                    if (side)
143:                       LED_RED_LEFT();
144:                    else
145:                       LED_RED_RIGHT();
146:                    break;
147:                case 1:
148:                    if (side)
149:                       LED_YELLOW_LEFT();
150:                    else
151:                       LED_YELLOW_RIGHT();
152:                    break;
153:                case 2:
154:                    if (side)
155:                       LED_GREEN_LEFT();
156:                    else
157:                       LED_GREEN_RIGHT();
158:                    break;
159:                case 3:
160:                    if (side)
161:                       LED_BLUE_LEFT();
162:                    else
163:                       LED_BLUE_RIGHT();
164:                    break;
165:               }
166:           }
167:           
168:           void inline blue_team_led(uint16_t pos) {
169:               if (pos < 512) {
170:                   if ((pos%2) == 0)
171:                       LED_BLUE_RIGHT();
172:                   else
173:                       LED_BLUE_LEFT();
174:               } else {
175:                   bits2_double_chase((pos - 512) / 128, pos%2);
176:               }
177:           }
178:           
179:           void inline red_team_led(uint16_t pos) {
180:               if (pos < 512) {
181:                   if ((pos%2) == 0)
182:                       LED_RED_RIGHT();
183:                   else
184:                       LED_RED_LEFT();
185:               } else {
186:                   bits2_double_chase((pos - 512) / 128, pos%2);
187:               }
188:           }
189:           
190:           
191:           void service_leds(void) {
192:               uint16_t temp_pos = led_pos;
193:               
194:               switch (led_mode) {
195:                   case LMODE_OFF:
196:                       all_off();
197:                       break;
198:                   case LMODE_CHASE_1:
199:                       all_off();
200:                       bits3_chase((temp_pos & 0b11111111) / 32);
201:                       break;
202:                   case LMODE_CHASE_FAST:
203:                       all_off();
204:                       bits3_chase(((temp_pos & 0b11111111) / 16) % 8);
205:                       break;
206:                   case LMODE_BLUE_TEAM:
207:                       all_off();
208:                       blue_team_led(temp_pos);
209:                       break;
210:                   case LMODE_RED_TEAM:
211:                       all_off();
212:                       red_team_led(temp_pos);
213:                       break;
214:               }
215:           }
216:           
217:           void timer0_setup() {
218:               OPTION_REGbits.PSA   = 0;      // Prescaler
020D  1683     BSF STATUS, 0x5
020E  1181     BCF TMR0, 0x3
219:               OPTION_REGbits.PS    = 0b010;  // 1:???8? Prescaler
020F  0801     MOVF TMR0, W
0210  39F8     ANDLW 0xF8
0211  3802     IORLW 0x2
0212  0081     MOVWF TMR0
220:               OPTION_REGbits.T0CS  = 0;      // Source = oscillator
0213  1281     BCF TMR0, 0x5
221:               INTCONbits.T0IF      = 0;      // Clear flag.
0214  110B     BCF INTCON, 0x2
222:               INTCONbits.T0IE      = 1;      // Enable timer0 interrupts
0215  168B     BSF INTCON, 0x5
223:               INTCONbits.GIE       = 1;      // Enable global interrupts
0216  178B     BSF INTCON, 0x7
224:           }
0217  0008     RETURN
---  /firmware.X/ir_transmitter.c  ----------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            #define _XTAL_FREQ 4000000
18:            
19:            #include <stdint.h>
20:            #include <xc.h>
21:            
22:            #include "ir_transmitter.h"
23:            
24:            #define TRANSMIT_OFF()      TRISB |= (1 << 2);
25:            #define TRANSMIT_ON()       TRISB &= ~(1 << 2);
26:            
27:            void transmit_byte(uint8_t data);
28:            void transmit_mark();
29:            void transmit_space_short();
30:            void transmit_space_long();
31:            
32:            void setup_ir_transmitter() {
33:                TRANSMIT_ON();
0227  30FB     MOVLW 0xFB
0228  1283     BCF STATUS, 0x5
0229  00A0     MOVWF __pcstackBANK0
022A  0820     MOVF __pcstackBANK0, W
022B  1683     BSF STATUS, 0x5
022C  0586     ANDWF PORTB, F
34:            }
022D  0008     RETURN
35:            
36:            void transmit_word(uint8_t addr, uint8_t command) {
015D  1283     BCF STATUS, 0x5
015E  00AB     MOVWF addr
37:                uint8_t inv_addr = addr ^ 0xFF;
015F  092B     COMF addr, W
0160  00A6     MOVWF 0x26
0161  0826     MOVF 0x26, W
0162  00A8     MOVWF inv_addr
38:                uint8_t inv_command = command ^ 0xFF;
0163  0925     COMF command, W
0164  00A6     MOVWF 0x26
0165  0826     MOVF 0x26, W
0166  00A9     MOVWF inv_command
39:                INTCONbits.GIE = 0;
0167  138B     BCF INTCON, 0x7
40:                // Start of frame
41:                register uint8_t i;
42:                for(i=16;i;--i)
0168  3010     MOVLW 0x10
0169  00A6     MOVWF 0x26
016A  0826     MOVF 0x26, W
016B  00AA     MOVWF i
016C  082A     MOVF i, W
016D  1903     BTFSC STATUS, 0x2
016E  2974     GOTO 0x174
0170  3001     MOVLW 0x1
0171  1283     BCF STATUS, 0x5
0172  02AA     SUBWF i, F
0173  296C     GOTO 0x16C
43:                    transmit_mark();
016F  21E4     CALL 0x1E4
44:                __delay_us(4500);
0174  3006     MOVLW 0x6
0175  1283     BCF STATUS, 0x5
0176  00A7     MOVWF 0x27
0177  30D6     MOVLW 0xD6
0178  00A6     MOVWF 0x26
0179  0BA6     DECFSZ 0x26, F
017A  2979     GOTO 0x179
017B  0BA7     DECFSZ 0x27, F
017C  2979     GOTO 0x179
017D  297E     GOTO 0x17E
45:                transmit_byte(addr);
017E  1283     BCF STATUS, 0x5
017F  082B     MOVF addr, W
0180  21BB     CALL 0x1BB
46:                transmit_byte(inv_addr);
0181  1283     BCF STATUS, 0x5
0182  0828     MOVF inv_addr, W
0183  21BB     CALL 0x1BB
47:                transmit_byte(command);
0184  1283     BCF STATUS, 0x5
0185  0825     MOVF command, W
0186  21BB     CALL 0x1BB
48:                transmit_byte(inv_command);
0187  1283     BCF STATUS, 0x5
0188  0829     MOVF inv_command, W
0189  21BB     CALL 0x1BB
49:                INTCONbits.GIE = 1;
018A  178B     BSF INTCON, 0x7
50:                __delay_us(4500);
018B  3006     MOVLW 0x6
018C  1283     BCF STATUS, 0x5
018D  00A7     MOVWF 0x27
018E  30D6     MOVLW 0xD6
018F  00A6     MOVWF 0x26
0190  0BA6     DECFSZ 0x26, F
0191  2990     GOTO 0x190
0192  0BA7     DECFSZ 0x27, F
0193  2990     GOTO 0x190
0194  2995     GOTO 0x195
51:            }
0195  0008     RETURN
52:            
53:            void transmit_byte(uint8_t data) {
01BB  1283     BCF STATUS, 0x5
01BC  00A3     MOVWF data
54:                register uint8_t i;
55:                for(i=8;i;--i) {
01BD  3008     MOVLW 0x8
01BE  00A2     MOVWF 0x22
01BF  0822     MOVF 0x22, W
01C0  00A4     MOVWF i
01C1  0824     MOVF i, W
01C2  1903     BTFSC STATUS, 0x2
01C3  0008     RETURN
01CE  3001     MOVLW 0x1
56:                    transmit_mark();
01C4  21E4     CALL 0x1E4
57:                    if(data & 1) {
01C5  1283     BCF STATUS, 0x5
01C6  1C23     BTFSS data, 0x0
01C7  29CA     GOTO 0x1CA
58:                        transmit_space_long();
01C8  2218     CALL 0x218
59:                    } else {
01C9  29CB     GOTO 0x1CB
60:                        transmit_space_short();
01CA  2220     CALL 0x220
61:                    }
62:                    data >>= 1;
01CB  1003     BCF STATUS, 0x0
01CC  1283     BCF STATUS, 0x5
01CD  0CA3     RRF data, F
01CE  3001     MOVLW 0x1
01CF  02A4     SUBWF i, F
01D0  29C1     GOTO 0x1C1
63:                }
64:            }
65:            
66:            void transmit_mark() {
67:                // Transmit a 38kHz timer for 562.5us, 21.375 cycles = 42 inversions
68:                // Called frequently.  Don't do much.
69:                // Toggle output (RB2))
70:                register uint8_t i;
71:                for(i=42;i;--i) {
01E4  302A     MOVLW 0x2A
01E5  1283     BCF STATUS, 0x5
01E6  00A0     MOVWF __pcstackBANK0
01E7  0820     MOVF __pcstackBANK0, W
01E8  00A1     MOVWF i
01E9  0821     MOVF i, W
01EA  1903     BTFSC STATUS, 0x2
01EB  0008     RETURN
01F1  3001     MOVLW 0x1
72:                  PORTB ^= 4; //rb2
01EC  3004     MOVLW 0x4
01ED  00A0     MOVWF __pcstackBANK0
01EE  0820     MOVF __pcstackBANK0, W
01EF  0686     XORWF PORTB, F
73:                  asm("NOP");
01F0  0000     NOP
01F1  3001     MOVLW 0x1
01F2  1283     BCF STATUS, 0x5
01F3  02A1     SUBWF i, F
01F4  29E9     GOTO 0x1E9
74:                }
75:            }
76:            
77:            void transmit_space_short() {
78:                __delay_us(562);
0220  30BA     MOVLW 0xBA
0221  1283     BCF STATUS, 0x5
0222  00A0     MOVWF __pcstackBANK0
0223  0BA0     DECFSZ __pcstackBANK0, F
0224  2A23     GOTO 0x223
0225  2A26     GOTO 0x226
79:            }
0226  0008     RETURN
80:            
81:            void transmit_space_long() {
82:                __delay_us(1675);
0218  30EF     MOVLW 0xEF
0219  1283     BCF STATUS, 0x5
021A  00A0     MOVWF __pcstackBANK0
021B  2A1C     GOTO 0x21C
021C  2A1D     GOTO 0x21D
021D  0BA0     DECFSZ __pcstackBANK0, F
021E  2A1B     GOTO 0x21B
83:            }
021F  0008     RETURN
---  /firmware.X/ir_decoder.c  --------------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            #include <stdint.h>
18:            #include <xc.h>
19:            
20:            #include "ir_decoder.h"
21:            
22:            #define MICROS_PER_CYCLE        140
23:            #define RESET_MICROS_PER_CYCLE  30
24:            #define START_MICROS            9000
25:            #define START_CYCLES            START_MICROS/MICROS_PER_CYCLE
26:            #define START_GAP_MICROS        4500
27:            #define START_GAP_CYCLES        START_GAP_MICROS/MICROS_PER_CYCLE
28:            #define BURST_MICROS            562
29:            #define BURST_CYCLES            BURST_MICROS/MICROS_PER_CYCLE
30:            #define ZERO_GAP_MICROS         562
31:            #define ZERO_GAP_CYCLES         ZERO_GAP_MICROS/MICROS_PER_CYCLE
32:            #define ONE_GAP_MICROS          1675
33:            #define ONE_GAP_CYCLES          ONE_GAP_MICROS/MICROS_PER_CYCLE
34:            
35:            // Reset timer 1 to trigger every MICROS_PER_CYCLE at 1MHz timer clock
36:            #define TIMER1_RESET() \
37:              do { \
38:                T1CONbits.TMR1ON = 0; \
39:                TMR1H = 255; \
40:                TMR1L = (255-MICROS_PER_CYCLE+RESET_MICROS_PER_CYCLE); \
41:                PIR1bits.TMR1IF = 0; \
42:                T1CONbits.TMR1ON = 1; \
43:              } while(0)
44:            
45:            #define IR_PIN PORTBbits.RB0
46:            
47:            #define BETWEEN(lo, val, hi) \
48:              (((lo) <= (val)) && ((val) <= (hi)))
49:            
50:            #define TIMING_MARGIN_START 15
51:            #define TIMING_MARGIN 2
52:            
53:            // Is a close to B?
54:            #define EQUALS_CLOSE(a, b) \
55:              BETWEEN((b)-TIMING_MARGIN, (a), (b)+TIMING_MARGIN)
56:            #define EQUALS_WIDE(a, b) \
57:              BETWEEN((b)-TIMING_MARGIN_START, (a), (b)+TIMING_MARGIN_START)
58:            
59:            typedef enum __PACK {
60:                STATE_IDLE,
61:                STATE_START,
62:                STATE_START_GAP,
63:                STATE_BURST,
64:                STATE_GAP,
65:            } ir_decoder_state_t;
66:            
67:            volatile uint32_t ir_data; // Data when valid
68:            volatile uint8_t ir_data_valid = 0; // Reader should reset this
69:            
70:            #define TRANSITION_STATE(new) \
71:                state_timer = 1; \
72:                decoder_state = (new)
73:            
74:            #define RESET_STATE() decoder_state = STATE_IDLE
75:            
76:            void timer1_interrupt_decoder() {
77:                /** Call from ISR when (TMR1IF && TMR1IE) */
78:                static volatile ir_decoder_state_t decoder_state = STATE_IDLE;
79:                static volatile uint8_t bit_count = 0;
80:                static volatile uint8_t state_timer = 0; // Time spent in current state
81:            
82:                TIMER1_RESET();
0021  1283     BCF STATUS, 0x5
0022  1010     BCF T1CON, 0x0
0023  30FF     MOVLW 0xFF
0024  008F     MOVWF TMR1H
0025  3091     MOVLW 0x91
0026  008E     MOVWF TMR1
0027  100C     BCF PIR1, 0x0
0028  1410     BSF T1CON, 0x0
83:            
84:                // Wait for previous data to be read
85:                if (ir_data_valid)
0029  0837     MOVF ir_data_valid, W
002A  1D03     BTFSS STATUS, 0x2
002B  0008     RETURN
002C  2951     GOTO 0x151
86:                    return;
87:            
88:                switch (decoder_state) {
0151  0836     MOVF decoder_state, W
0152  0084     MOVWF FSR
0153  3005     MOVLW 0x5
0154  0204     SUBWF FSR, W
0155  1803     BTFSC STATUS, 0x0
0156  0008     RETURN
0157  3002     MOVLW 0x2
0158  008A     MOVWF PCLATH
0159  302E     MOVLW 0x2E
015A  0704     ADDWF FSR, W
015B  0082     MOVWF PCL
022E  282D     GOTO 0x2D
89:                    case STATE_IDLE:
90:                        // Idling
91:                        if (IR_PIN) // Still idle
002D  1806     BTFSC PORTB, 0x0
002E  0008     RETURN
92:                            return;
93:                        TRANSITION_STATE(STATE_START);
002F  3001     MOVLW 0x1
0030  00F0     MOVWF __pcstackCOMMON
0031  0870     MOVF __pcstackCOMMON, W
0032  00B4     MOVWF state_timer
0033  3001     MOVLW 0x1
0034  00F0     MOVWF __pcstackCOMMON
0035  0870     MOVF __pcstackCOMMON, W
0036  00B6     MOVWF decoder_state
94:                        bit_count = 0;
0037  01B5     CLRF bit_count
95:                        return;
0038  0008     RETURN
96:                    case STATE_START:
97:                        // In the start bit
98:                        if (!IR_PIN) {
0039  1806     BTFSC PORTB, 0x0
003A  2840     GOTO 0x40
99:                            state_timer++;
003B  3001     MOVLW 0x1
003C  00F0     MOVWF __pcstackCOMMON
003D  0870     MOVF __pcstackCOMMON, W
003E  07B4     ADDWF state_timer, F
100:                           return;
003F  0008     RETURN
101:                       }
102:                       // Check start burst length.
103:                       if (EQUALS_WIDE(state_timer, START_CYCLES)) {
0040  3031     MOVLW 0x31
0041  0234     SUBWF state_timer, W
0042  1C03     BTFSS STATUS, 0x0
0043  2851     GOTO 0x51
0044  3050     MOVLW 0x50
0045  0234     SUBWF state_timer, W
0046  1803     BTFSC STATUS, 0x0
0047  2851     GOTO 0x51
104:                           TRANSITION_STATE(STATE_START_GAP);
0048  3001     MOVLW 0x1
0049  00F0     MOVWF __pcstackCOMMON
004A  0870     MOVF __pcstackCOMMON, W
004B  00B4     MOVWF state_timer
004C  3002     MOVLW 0x2
004D  00F0     MOVWF __pcstackCOMMON
004E  0870     MOVF __pcstackCOMMON, W
004F  00B6     MOVWF decoder_state
105:                           return;
0050  0008     RETURN
106:                       }
107:                       // Not long enough for start burst
108:                       RESET_STATE();
0051  01B6     CLRF decoder_state
109:                       return;
0052  0008     RETURN
110:                   case STATE_START_GAP:
111:                       // In the gap
112:                       if (IR_PIN) {
0053  1C06     BTFSS PORTB, 0x0
0054  285A     GOTO 0x5A
113:                           state_timer++;
0055  3001     MOVLW 0x1
0056  00F0     MOVWF __pcstackCOMMON
0057  0870     MOVF __pcstackCOMMON, W
0058  07B4     ADDWF state_timer, F
114:                           return;
0059  0008     RETURN
115:                       }
116:                       if (!EQUALS_WIDE(state_timer, START_GAP_CYCLES)) {
005A  3011     MOVLW 0x11
005B  0234     SUBWF state_timer, W
005C  1C03     BTFSS STATUS, 0x0
005D  2862     GOTO 0x62
005E  3030     MOVLW 0x30
005F  0234     SUBWF state_timer, W
0060  1C03     BTFSS STATUS, 0x0
0061  2864     GOTO 0x64
117:                           RESET_STATE();
0062  01B6     CLRF decoder_state
118:                           return;
0063  0008     RETURN
119:                       }
120:                       // Have started data burst
121:                       TRANSITION_STATE(STATE_BURST);
0064  3001     MOVLW 0x1
0065  00F0     MOVWF __pcstackCOMMON
0066  0870     MOVF __pcstackCOMMON, W
0067  00B4     MOVWF state_timer
0068  3003     MOVLW 0x3
0069  00F0     MOVWF __pcstackCOMMON
006A  0870     MOVF __pcstackCOMMON, W
006B  00B6     MOVWF decoder_state
122:                       return;
006C  0008     RETURN
123:                   case STATE_BURST:
124:                       if (!IR_PIN) {
006D  1806     BTFSC PORTB, 0x0
006E  2874     GOTO 0x74
125:                           state_timer++;
006F  3001     MOVLW 0x1
0070  00F0     MOVWF __pcstackCOMMON
0071  0870     MOVF __pcstackCOMMON, W
0072  07B4     ADDWF state_timer, F
126:                           return;
0073  0008     RETURN
127:                       }
128:                       // Burst is over
129:                       if (!EQUALS_CLOSE(state_timer, BURST_CYCLES)) {
0074  3002     MOVLW 0x2
0075  0234     SUBWF state_timer, W
0076  1C03     BTFSS STATUS, 0x0
0077  287C     GOTO 0x7C
0078  3007     MOVLW 0x7
0079  0234     SUBWF state_timer, W
007A  1C03     BTFSS STATUS, 0x0
007B  287E     GOTO 0x7E
130:                           RESET_STATE();
007C  01B6     CLRF decoder_state
131:                       } else {
007D  0008     RETURN
132:                           TRANSITION_STATE(STATE_GAP);
007E  3001     MOVLW 0x1
007F  00F0     MOVWF __pcstackCOMMON
0080  0870     MOVF __pcstackCOMMON, W
0081  00B4     MOVWF state_timer
0082  3004     MOVLW 0x4
0083  00F0     MOVWF __pcstackCOMMON
0084  0870     MOVF __pcstackCOMMON, W
0085  00B6     MOVWF decoder_state
133:                       }
134:                       return;
0086  0008     RETURN
135:                   case STATE_GAP:
136:                       if (IR_PIN) {
0087  1C06     BTFSS PORTB, 0x0
0088  288E     GOTO 0x8E
137:                           state_timer++;
0089  3001     MOVLW 0x1
008A  00F0     MOVWF __pcstackCOMMON
008B  0870     MOVF __pcstackCOMMON, W
008C  07B4     ADDWF state_timer, F
138:                           return;
008D  0008     RETURN
139:                       }
140:                       if (EQUALS_CLOSE(state_timer, ZERO_GAP_CYCLES)) {
008E  3002     MOVLW 0x2
008F  0234     SUBWF state_timer, W
0090  1C03     BTFSS STATUS, 0x0
0091  28B8     GOTO 0xB8
0092  3007     MOVLW 0x7
0093  0234     SUBWF state_timer, W
0094  1803     BTFSC STATUS, 0x0
0095  28B8     GOTO 0xB8
141:                           // LSB first
142:                           ir_data &= ~(1ul << (31ul - bit_count));
0096  3001     MOVLW 0x1
0097  00F0     MOVWF __pcstackCOMMON
0098  3000     MOVLW 0x0
0099  00F1     MOVWF 0x71
009A  3000     MOVLW 0x0
009B  00F2     MOVWF 0x72
009C  3000     MOVLW 0x0
009D  00F3     MOVWF 0x73
009E  0335     DECF bit_count, W
009F  3AFF     XORLW 0xFF
00A0  3E1F     ADDLW 0x1F
00A1  3E01     ADDLW 0x1
00A2  28A8     GOTO 0xA8
00A3  1003     BCF STATUS, 0x0
00A4  0DF0     RLF __pcstackCOMMON, F
00A5  0DF1     RLF 0x71, F
00A6  0DF2     RLF 0x72, F
00A7  0DF3     RLF 0x73, F
00A8  3EFF     ADDLW 0xFF
00A9  1D03     BTFSS STATUS, 0x2
00AA  28A3     GOTO 0xA3
00AB  09F0     COMF __pcstackCOMMON, F
00AC  09F1     COMF 0x71, F
00AD  09F2     COMF 0x72, F
00AE  09F3     COMF 0x73, F
00AF  0870     MOVF __pcstackCOMMON, W
00B0  05AD     ANDWF ir_data, F
00B1  0871     MOVF 0x71, W
00B2  05AE     ANDWF 0x2E, F
00B3  0872     MOVF 0x72, W
00B4  05AF     ANDWF 0x2F, F
00B5  0873     MOVF 0x73, W
00B6  05B0     ANDWF 0x30, F
143:                       } else if (EQUALS_CLOSE(state_timer, ONE_GAP_CYCLES)) {
00B7  28E0     GOTO 0xE0
00B8  3009     MOVLW 0x9
00B9  0234     SUBWF state_timer, W
00BA  1C03     BTFSS STATUS, 0x0
00BB  28DE     GOTO 0xDE
00BC  300E     MOVLW 0xE
00BD  0234     SUBWF state_timer, W
00BE  1803     BTFSC STATUS, 0x0
00BF  28DE     GOTO 0xDE
144:                           // LSB first
145:                           ir_data |= (1ul << (31ul - bit_count));
00C0  3001     MOVLW 0x1
00C1  00F0     MOVWF __pcstackCOMMON
00C2  3000     MOVLW 0x0
00C3  00F1     MOVWF 0x71
00C4  3000     MOVLW 0x0
00C5  00F2     MOVWF 0x72
00C6  3000     MOVLW 0x0
00C7  00F3     MOVWF 0x73
00C8  0335     DECF bit_count, W
00C9  3AFF     XORLW 0xFF
00CA  3E1F     ADDLW 0x1F
00CB  3E01     ADDLW 0x1
00CC  28D2     GOTO 0xD2
00CD  1003     BCF STATUS, 0x0
00CE  0DF0     RLF __pcstackCOMMON, F
00CF  0DF1     RLF 0x71, F
00D0  0DF2     RLF 0x72, F
00D1  0DF3     RLF 0x73, F
00D2  3EFF     ADDLW 0xFF
00D3  1D03     BTFSS STATUS, 0x2
00D4  28CD     GOTO 0xCD
00D5  0870     MOVF __pcstackCOMMON, W
00D6  04AD     IORWF ir_data, F
00D7  0871     MOVF 0x71, W
00D8  04AE     IORWF 0x2E, F
00D9  0872     MOVF 0x72, W
00DA  04AF     IORWF 0x2F, F
00DB  0873     MOVF 0x73, W
00DC  04B0     IORWF 0x30, F
146:                       } else {
00DD  28E0     GOTO 0xE0
147:                           // Gone invalid
148:                           RESET_STATE();
00DE  01B6     CLRF decoder_state
149:                           return;
00DF  0008     RETURN
150:                       }
151:                       bit_count++;
00E0  3001     MOVLW 0x1
00E1  00F0     MOVWF __pcstackCOMMON
00E2  0870     MOVF __pcstackCOMMON, W
00E3  07B5     ADDWF bit_count, F
152:                       if (bit_count == 32) {
00E4  3020     MOVLW 0x20
00E5  0635     XORWF bit_count, W
00E6  1D03     BTFSS STATUS, 0x2
00E7  2948     GOTO 0x148
153:                           T1CONbits.TMR1ON = 0;
00E8  1010     BCF T1CON, 0x0
154:                           ir_data_valid = 1;
00E9  3001     MOVLW 0x1
00EA  00F0     MOVWF __pcstackCOMMON
00EB  0870     MOVF __pcstackCOMMON, W
00EC  00B7     MOVWF ir_data_valid
155:                           //debug
156:                           while(bit_count) {
00ED  1283     BCF STATUS, 0x5
00EE  0835     MOVF bit_count, W
00EF  1903     BTFSC STATUS, 0x2
00F0  2945     GOTO 0x145
157:                               PORTBbits.RB2 = 1;
00F1  1506     BSF PORTB, 0x2
158:                               for(int k=0;k<25;k++)
00F2  01F5     CLRF k
00F3  01F6     CLRF 0x76
00F4  0876     MOVF 0x76, W
00F5  3A80     XORLW 0x80
00F6  00FF     MOVWF 0x7F
00F7  3080     MOVLW 0x80
00F8  027F     SUBWF 0x7F, W
00F9  1D03     BTFSS STATUS, 0x2
00FA  28FD     GOTO 0xFD
00FB  3019     MOVLW 0x19
00FC  0275     SUBWF k, W
00FD  1803     BTFSC STATUS, 0x0
00FE  2911     GOTO 0x111
0100  3001     MOVLW 0x1
0101  07F5     ADDWF k, F
0102  1803     BTFSC STATUS, 0x0
0103  0AF6     INCF 0x76, F
0104  3000     MOVLW 0x0
0105  07F6     ADDWF 0x76, F
0106  0876     MOVF 0x76, W
0107  3A80     XORLW 0x80
0108  00FF     MOVWF 0x7F
0109  3080     MOVLW 0x80
010A  027F     SUBWF 0x7F, W
010B  1D03     BTFSS STATUS, 0x2
010C  290F     GOTO 0x10F
010D  3019     MOVLW 0x19
010E  0275     SUBWF k, W
010F  1C03     BTFSS STATUS, 0x0
0110  28FF     GOTO 0xFF
159:                                   NOP();
00FF  0000     NOP
160:                               PORTBbits.RB2 = ((ir_data>>(--bit_count)) & 1);
0111  1283     BCF STATUS, 0x5
0112  082D     MOVF ir_data, W
0113  00F0     MOVWF __pcstackCOMMON
0114  082E     MOVF 0x2E, W
0115  00F1     MOVWF 0x71
0116  082F     MOVF 0x2F, W
0117  00F2     MOVWF 0x72
0118  0830     MOVF 0x30, W
0119  00F3     MOVWF 0x73
011A  3001     MOVLW 0x1
011B  02B5     SUBWF bit_count, F
011C  0A35     INCF bit_count, W
011D  2923     GOTO 0x123
011E  1003     BCF STATUS, 0x0
011F  0CF3     RRF 0x73, F
0120  0CF2     RRF 0x72, F
0121  0CF1     RRF 0x71, F
0122  0CF0     RRF __pcstackCOMMON, F
0123  3EFF     ADDLW 0xFF
0124  1D03     BTFSS STATUS, 0x2
0125  291E     GOTO 0x11E
0126  0870     MOVF __pcstackCOMMON, W
0127  3901     ANDLW 0x1
0128  00F4     MOVWF 0x74
0129  0DF4     RLF 0x74, F
012A  0DF4     RLF 0x74, F
012B  0806     MOVF PORTB, W
012C  0674     XORWF 0x74, W
012D  39FB     ANDLW 0xFB
012E  0674     XORWF 0x74, W
012F  0086     MOVWF PORTB
161:                               for(int k=0;k<100;k++)
0130  01F7     CLRF k
0131  01F8     CLRF 0x78
0132  0878     MOVF 0x78, W
0133  3A80     XORLW 0x80
0134  00FF     MOVWF 0x7F
0135  3080     MOVLW 0x80
0136  027F     SUBWF 0x7F, W
0137  1D03     BTFSS STATUS, 0x2
0138  293B     GOTO 0x13B
0139  3064     MOVLW 0x64
013A  0277     SUBWF k, W
013B  1803     BTFSC STATUS, 0x0
013C  28ED     GOTO 0xED
013E  3001     MOVLW 0x1
013F  07F7     ADDWF k, F
0140  1803     BTFSC STATUS, 0x0
0141  0AF8     INCF 0x78, F
0142  3000     MOVLW 0x0
0143  07F8     ADDWF 0x78, F
0144  2932     GOTO 0x132
162:                                   NOP();
013D  0000     NOP
163:                           }
164:                           T1CONbits.TMR1ON = 1;
0145  1410     BSF T1CON, 0x0
165:                           RESET_STATE();
0146  01B6     CLRF decoder_state
166:                       } else {
0147  0008     RETURN
167:                           TRANSITION_STATE(STATE_BURST);
0148  3001     MOVLW 0x1
0149  00F0     MOVWF __pcstackCOMMON
014A  0870     MOVF __pcstackCOMMON, W
014B  00B4     MOVWF state_timer
014C  3003     MOVLW 0x3
014D  00F0     MOVWF __pcstackCOMMON
014E  0870     MOVF __pcstackCOMMON, W
014F  00B6     MOVWF decoder_state
168:                       }
169:                       return;
170:               }
0150  0008     RETURN
171:           }
015C  0008     RETURN
172:           
173:           void setup_ir_decoder() {
174:               // Setup IR PIN as input
175:               TRISBbits.TRISB0 = 1;
01D1  1683     BSF STATUS, 0x5
01D2  1406     BSF PORTB, 0x0
176:               // Setup the timer
177:               T1CONbits.T1SYNC = 1; // bit 2 Timer1 External Clock Input Synchronization Control bit...1 = Do not synchronize external clock input
01D3  1283     BCF STATUS, 0x5
01D4  1510     BSF T1CON, 0x2
178:               PIE1bits.TMR1IE = 1; // Timer 1 triggers interrupt
01D5  1683     BSF STATUS, 0x5
01D6  140C     BSF PIR1, 0x0
179:               INTCONbits.PEIE = 1; // Peripheral interrupts
01D7  170B     BSF INTCON, 0x6
180:               INTCONbits.GIE = 1; // Global interrupts.
01D8  178B     BSF INTCON, 0x7
181:               TIMER1_RESET();
01D9  1283     BCF STATUS, 0x5
01DA  1010     BCF T1CON, 0x0
01DB  30FF     MOVLW 0xFF
01DC  008F     MOVWF TMR1H
01DD  3091     MOVLW 0x91
01DE  008E     MOVWF TMR1
01DF  100C     BCF PIR1, 0x0
01E0  1410     BSF T1CON, 0x0
182:               // debugging
183:               TRISBbits.TRISB2 = 0;
01E1  1683     BSF STATUS, 0x5
01E2  1106     BCF PORTB, 0x2
184:           }
01E3  0008     RETURN
185:           
