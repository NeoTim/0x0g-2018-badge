Disassembly Listing for firmware_dev
Generated From:
/firmware.X/dist/default/production/firmware.X.production.elf
Jul 10, 2018 11:53:33 PM

---  /firmware.X/main.c  --------------------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            /*
18:             * File:   main.c
19:             * Author: David
20:             *
21:             * Created on May 15, 2018, 3:16 AM
22:             */
23:            
24:            // CONFIG
25:            #pragma config FOSC = XT        // Oscillator Selection bits (XT oscillator)
26:            #pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT enabled)
27:            #pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
28:            #pragma config BOREN = OFF      // Brown-out Reset Enable bit (BOR disabled)
29:            #pragma config BODENV = 40      // Brown-out Reset Voltage bit (VBOR set to 4.0V)
30:            #pragma config CP = OFF         // Code Protect (Program memory code protection is disabled)
31:            
32:            #include <xc.h>
33:            
34:            #include "ir_decoder.h"
35:            #include "ir_transmitter.h"
36:            #include "leds.h"
37:            
38:            volatile uint8_t move_leds = 1;
39:            // Transmitting or receiving?
40:            volatile uint8_t ir_transmitting = 0;
41:            
42:            static void interrupt ISR(void) {
0004  00FE     MOVWF 0x7E
43:                if (INTCONbits.T0IF) {
018A  1D0B     BTFSS INTCON, 0x2
018B  2992     GOTO 0x192
44:                    if (move_leds)
018C  0838     MOVF move_leds, W
018D  1903     BTFSC STATUS, 0x2
018E  2991     GOTO 0x191
45:                        timer0_interrupt();
018F  21E9     CALL 0x1E9
0190  2992     GOTO 0x192
46:                    else
47:                        INTCONbits.T0IF = 0;
0191  110B     BCF INTCON, 0x2
48:                }
49:                if (PIR1bits.TMR1IF) {
0192  1283     BCF STATUS, 0x5
0193  1C0C     BTFSS PIR1, 0x0
0194  29A4     GOTO 0x1A4
50:                    if (!ir_transmitting) {
0195  0832     MOVF ir_transmitting, W
0196  1D03     BTFSS STATUS, 0x2
0197  29A3     GOTO 0x1A3
51:                        timer1_interrupt_decoder();
0198  2021     CALL 0x21
52:                        if (ir_data_valid) {
0199  1283     BCF STATUS, 0x5
019A  0836     MOVF ir_data_valid, W
019B  1903     BTFSC STATUS, 0x2
019C  29A4     GOTO 0x1A4
53:                            move_leds ^= 1;
019D  3001     MOVLW 0x1
019E  00F9     MOVWF 0x79
019F  0879     MOVF 0x79, W
01A0  06B8     XORWF move_leds, F
54:                            ir_data_valid = 0;
01A1  01B6     CLRF ir_data_valid
55:                        }
56:                    } else {
01A2  29A4     GOTO 0x1A4
57:                        PIR1bits.TMR1IF = 0;
01A3  100C     BCF PIR1, 0x0
58:                    }
59:                }
60:            }
01A4  087D     MOVF 0x7D, W
01A5  00FF     MOVWF 0x7F
01A6  087C     MOVF 0x7C, W
01A7  008A     MOVWF PCLATH
01A8  087B     MOVF 0x7B, W
01A9  0084     MOVWF FSR
01AA  0E7A     SWAPF 0x7A, W
01AB  0083     MOVWF STATUS
01AC  0EFE     SWAPF 0x7E, F
01AD  0E7E     SWAPF 0x7E, W
01AE  0009     RETFIE
61:            
62:            void main(void) {
63:                timer0_setup();
01F6  2201     CALL 0x201
64:                setup_ir_decoder();
01F7  21C5     CALL 0x1C5
65:                setup_ir_transmitter();
01F8  2213     CALL 0x213
66:                
67:                while (1){
0200  29F9     GOTO 0x1F9
68:                    transmit_word(0x55,0x55);
01F9  3055     MOVLW 0x55
01FA  1283     BCF STATUS, 0x5
01FB  00AB     MOVWF 0x2B
01FC  082B     MOVF 0x2B, W
01FD  00A5     MOVWF command
01FE  3055     MOVLW 0x55
01FF  215D     CALL 0x15D
0200  29F9     GOTO 0x1F9
69:                    //service_leds();
70:                }
71:            }
---  /firmware.X/leds.c  --------------------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            #include <stdint.h>
18:            
19:            #include <xc.h>
20:            
21:            #include "leds.h"
22:            
23:            volatile uint16_t led_pos = 0;
24:            volatile uint8_t led_mode = LMODE_BLUE_TEAM; // default mode
25:            
26:            #define LED_RED_LEFT()          leda_on(0, 0)
27:            #define LED_RED_RIGHT()         leda_on(0, 1)
28:            #define LED_YELLOW_LEFT()       leda_on(2, 0)
29:            #define LED_YELLOW_RIGHT()      leda_on(2, 1)
30:            #define LED_GREEN_LEFT()        ledb_on(3, 0)
31:            #define LED_GREEN_RIGHT()       leda_on(3, 0)
32:            #define LED_BLUE_LEFT()         ledb_on(3, 1)
33:            #define LED_BLUE_RIGHT()        leda_on(3, 1)
34:            
35:            static inline void all_off();
36:            static inline void leda_on(uint8_t pos, uint8_t dir);
37:            static inline void ledb_on(uint8_t pos, uint8_t dir);
38:            
39:            /*
40:             * Turn on exactly one LED
41:             */
42:            void exactly_on(uint8_t which) {
43:                all_off();
44:                switch (which) {
45:                    case 0:
46:                        LED_RED_LEFT();
47:                        break;
48:                    case 1:
49:                        LED_YELLOW_LEFT();
50:                        break;
51:                    case 2:
52:                        LED_GREEN_LEFT();
53:                        break;
54:                    case 3:
55:                        LED_BLUE_LEFT();
56:                        break;
57:                    case 4:
58:                        LED_RED_RIGHT();
59:                        break;
60:                    case 5:
61:                        LED_YELLOW_RIGHT();
62:                        break;
63:                    case 6:
64:                        LED_GREEN_RIGHT();
65:                        break;
66:                    case 7:
67:                        LED_BLUE_RIGHT();
68:                        break;
69:                }
70:            }
71:            
72:            /*
73:             * Turn all LEDs off
74:             */
75:            static inline void all_off() {
76:                TRISA |= 1 | (1 << 2) | (1 << 3);
77:                TRISB |= (1 << 3);
78:            }
79:            
80:            /*
81:             * Turn a LED on on PORTA
82:             */
83:            static inline void leda_on(uint8_t pos, uint8_t dir) {
84:                if (dir)
85:                    PORTA |= (1u<<pos);
86:                else
87:                    PORTA &= ~(1u<<pos);
88:                TRISA &= ~(1u<<pos);
89:            }
90:            
91:            /*
92:             * Turn a LED on on PORTB
93:             */
94:            static inline void ledb_on(uint8_t pos, uint8_t dir) {
95:                if (dir)
96:                    PORTB |= (1u<<pos);
97:                else
98:                    PORTB &= ~(1u<<pos);
99:                TRISB &= ~(1u<<pos);
100:           }
101:           
102:           void timer0_interrupt(void) {
103:               led_pos++;
01E9  3001     MOVLW 0x1
01EA  1283     BCF STATUS, 0x5
01EB  07B0     ADDWF led_pos, F
01EC  1803     BTFSC STATUS, 0x0
01ED  0AB1     INCF 0x31, F
01EE  3000     MOVLW 0x0
01EF  07B1     ADDWF 0x31, F
104:               led_pos &= 0b1111111111;
01F0  30FF     MOVLW 0xFF
01F1  05B0     ANDWF led_pos, F
01F2  3003     MOVLW 0x3
01F3  05B1     ANDWF 0x31, F
105:               INTCONbits.T0IF = 0;  // Clear flag
01F4  110B     BCF INTCON, 0x2
106:           }
01F5  0008     RETURN
107:           
108:           void bits3_chase(uint8_t pos) {
109:               switch (pos) {
110:                default:
111:                case 0:
112:                    LED_RED_LEFT();
113:                    break;
114:                case 1:
115:                    LED_YELLOW_LEFT();
116:                    break;
117:                case 2:
118:                    LED_GREEN_LEFT();
119:                    break;
120:                case 3:
121:                    LED_BLUE_LEFT();
122:                    break;
123:                case 4:
124:                    LED_RED_RIGHT();
125:                    break;
126:                case 5:
127:                    LED_YELLOW_RIGHT();
128:                    break;
129:                case 6:
130:                    LED_GREEN_RIGHT();
131:                    break;
132:                case 7:
133:                    LED_BLUE_RIGHT();
134:                    break;
135:               }
136:           }
137:           
138:           void bits2_double_chase(uint8_t pos, uint8_t side) {
139:               switch (pos) {
140:                default:
141:                case 0:
142:                    if (side)
143:                       LED_RED_LEFT();
144:                    else
145:                       LED_RED_RIGHT();
146:                    break;
147:                case 1:
148:                    if (side)
149:                       LED_YELLOW_LEFT();
150:                    else
151:                       LED_YELLOW_RIGHT();
152:                    break;
153:                case 2:
154:                    if (side)
155:                       LED_GREEN_LEFT();
156:                    else
157:                       LED_GREEN_RIGHT();
158:                    break;
159:                case 3:
160:                    if (side)
161:                       LED_BLUE_LEFT();
162:                    else
163:                       LED_BLUE_RIGHT();
164:                    break;
165:               }
166:           }
167:           
168:           void inline blue_team_led(uint16_t pos) {
169:               if (pos < 512) {
170:                   if ((pos%2) == 0)
171:                       LED_BLUE_RIGHT();
172:                   else
173:                       LED_BLUE_LEFT();
174:               } else {
175:                   bits2_double_chase((pos - 512) / 128, pos%2);
176:               }
177:           }
178:           
179:           void inline red_team_led(uint16_t pos) {
180:               if (pos < 512) {
181:                   if ((pos%2) == 0)
182:                       LED_RED_RIGHT();
183:                   else
184:                       LED_RED_LEFT();
185:               } else {
186:                   bits2_double_chase((pos - 512) / 128, pos%2);
187:               }
188:           }
189:           
190:           
191:           void service_leds(void) {
192:               uint16_t temp_pos = led_pos;
193:               
194:               switch (led_mode) {
195:                   case LMODE_OFF:
196:                       all_off();
197:                       break;
198:                   case LMODE_CHASE_1:
199:                       all_off();
200:                       bits3_chase((temp_pos & 0b11111111) / 32);
201:                       break;
202:                   case LMODE_CHASE_FAST:
203:                       all_off();
204:                       bits3_chase(((temp_pos & 0b11111111) / 16) % 8);
205:                       break;
206:                   case LMODE_BLUE_TEAM:
207:                       all_off();
208:                       blue_team_led(temp_pos);
209:                       break;
210:                   case LMODE_RED_TEAM:
211:                       all_off();
212:                       red_team_led(temp_pos);
213:                       break;
214:               }
215:           }
216:           
217:           void timer0_setup() {
218:               OPTION_REGbits.PSA   = 0;      // Prescaler
0201  1683     BSF STATUS, 0x5
0202  1181     BCF TMR0, 0x3
219:               OPTION_REGbits.PS    = 0b010;  // 1:???8? Prescaler
0203  0801     MOVF TMR0, W
0204  39F8     ANDLW 0xF8
0205  3802     IORLW 0x2
0206  0081     MOVWF TMR0
220:               OPTION_REGbits.T0CS  = 0;      // Source = oscillator
0207  1281     BCF TMR0, 0x5
221:               INTCONbits.T0IF      = 0;      // Clear flag.
0208  110B     BCF INTCON, 0x2
222:               INTCONbits.T0IE      = 1;      // Enable timer0 interrupts
0209  168B     BSF INTCON, 0x5
223:               INTCONbits.GIE       = 1;      // Enable global interrupts
020A  178B     BSF INTCON, 0x7
224:           }
020B  0008     RETURN
---  /firmware.X/ir_transmitter.c  ----------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            #define _XTAL_FREQ 1000000
18:            
19:            #include <stdint.h>
20:            #include <xc.h>
21:            
22:            #include "ir_transmitter.h"
23:            
24:            #define TRANSMIT_OFF()      TRISB |= (1 << 2);
25:            #define TRANSMIT_ON()       TRISB &= ~(1 << 2);
26:            
27:            void transmit_byte(uint8_t data);
28:            void transmit_mark();
29:            void transmit_space_short();
30:            void transmit_space_long();
31:            
32:            void setup_ir_transmitter() {
33:                TRANSMIT_ON();
0213  30FB     MOVLW 0xFB
0214  1283     BCF STATUS, 0x5
0215  00A0     MOVWF __pcstackBANK0
0216  0820     MOVF __pcstackBANK0, W
0217  1683     BSF STATUS, 0x5
0218  0586     ANDWF PORTB, F
34:            }
0219  0008     RETURN
35:            
36:            void transmit_word(uint8_t addr, uint8_t command) {
015D  1283     BCF STATUS, 0x5
015E  00AA     MOVWF addr
37:                uint8_t inv_addr = addr ^ 0xFF;
015F  092A     COMF addr, W
0160  00A6     MOVWF 0x26
0161  0826     MOVF 0x26, W
0162  00A7     MOVWF inv_addr
38:                uint8_t inv_command = command ^ 0xFF;
0163  0925     COMF command, W
0164  00A6     MOVWF 0x26
0165  0826     MOVF 0x26, W
0166  00A8     MOVWF inv_command
39:                INTCONbits.GIE = 0;
0167  138B     BCF INTCON, 0x7
40:                // Start of frame
41:                register uint8_t i;
42:                for(i=16;i;--i)
0168  3010     MOVLW 0x10
0169  00A6     MOVWF 0x26
016A  0826     MOVF 0x26, W
016B  00A9     MOVWF i
016C  0829     MOVF i, W
016D  1903     BTFSC STATUS, 0x2
016E  2974     GOTO 0x174
0170  3001     MOVLW 0x1
0171  1283     BCF STATUS, 0x5
0172  02A9     SUBWF i, F
0173  296C     GOTO 0x16C
43:                    transmit_mark();
016F  21D8     CALL 0x1D8
44:                __delay_us(4500);
0174  30E0     MOVLW 0xE0
0175  1283     BCF STATUS, 0x5
0176  00A6     MOVWF 0x26
0177  2978     GOTO 0x178
0178  0BA6     DECFSZ 0x26, F
0179  2977     GOTO 0x177
017A  297B     GOTO 0x17B
017B  0000     NOP
45:                transmit_byte(addr);
017C  1283     BCF STATUS, 0x5
017D  082A     MOVF addr, W
017E  21AF     CALL 0x1AF
46:                transmit_byte(inv_addr);
017F  1283     BCF STATUS, 0x5
0180  0827     MOVF inv_addr, W
0181  21AF     CALL 0x1AF
47:                transmit_byte(command);
0182  1283     BCF STATUS, 0x5
0183  0825     MOVF command, W
0184  21AF     CALL 0x1AF
48:                transmit_byte(inv_command);
0185  1283     BCF STATUS, 0x5
0186  0828     MOVF inv_command, W
0187  21AF     CALL 0x1AF
49:                INTCONbits.GIE = 1;    
0188  178B     BSF INTCON, 0x7
50:            }
0189  0008     RETURN
51:            
52:            void transmit_byte(uint8_t data) {
01AF  1283     BCF STATUS, 0x5
01B0  00A3     MOVWF data
53:                register uint8_t i;
54:                for(i=8;i;--i) {
01B1  3008     MOVLW 0x8
01B2  00A2     MOVWF 0x22
01B3  0822     MOVF 0x22, W
01B4  00A4     MOVWF i
01B5  0824     MOVF i, W
01B6  1903     BTFSC STATUS, 0x2
01B7  0008     RETURN
01C2  3001     MOVLW 0x1
55:                    transmit_mark();
01B8  21D8     CALL 0x1D8
56:                    if(data & 1) {
01B9  1283     BCF STATUS, 0x5
01BA  1C23     BTFSS data, 0x0
01BB  29BE     GOTO 0x1BE
57:                        transmit_space_long();
01BC  220C     CALL 0x20C
58:                    } else {
01BD  29BF     GOTO 0x1BF
59:                        transmit_space_short();
01BE  221A     CALL 0x21A
60:                    }
61:                    data >>= 1;
01BF  1003     BCF STATUS, 0x0
01C0  1283     BCF STATUS, 0x5
01C1  0CA3     RRF data, F
01C2  3001     MOVLW 0x1
01C3  02A4     SUBWF i, F
01C4  29B5     GOTO 0x1B5
62:                }
63:            }
64:            
65:            void transmit_mark() {
66:                // Transmit a 38kHz timer for 562.5us, 21.375 cycles = 42 inversions
67:                // Called frequently.  Don't do much.
68:                // Toggle output (RB2))
69:                register uint8_t i;
70:                for(i=42;i;--i) {
01D8  302A     MOVLW 0x2A
01D9  1283     BCF STATUS, 0x5
01DA  00A0     MOVWF __pcstackBANK0
01DB  0820     MOVF __pcstackBANK0, W
01DC  00A1     MOVWF i
01DD  0821     MOVF i, W
01DE  1903     BTFSC STATUS, 0x2
01DF  0008     RETURN
01E5  3001     MOVLW 0x1
71:                  PORTB ^= 4; //rb2
01E0  3004     MOVLW 0x4
01E1  00A0     MOVWF __pcstackBANK0
01E2  0820     MOVF __pcstackBANK0, W
01E3  0686     XORWF PORTB, F
72:                  asm("NOP");
01E4  0000     NOP
01E5  3001     MOVLW 0x1
01E6  1283     BCF STATUS, 0x5
01E7  02A1     SUBWF i, F
01E8  29DD     GOTO 0x1DD
73:                }
74:            }
75:            
76:            void transmit_space_short() {
77:                __delay_us(562);
021A  302E     MOVLW 0x2E
021B  1283     BCF STATUS, 0x5
021C  00A0     MOVWF __pcstackBANK0
021D  0BA0     DECFSZ __pcstackBANK0, F
021E  2A1D     GOTO 0x21D
78:            }
021F  0008     RETURN
79:            
80:            void transmit_space_long() {
81:                __delay_us(1687);
020C  308B     MOVLW 0x8B
020D  1283     BCF STATUS, 0x5
020E  00A0     MOVWF __pcstackBANK0
020F  0BA0     DECFSZ __pcstackBANK0, F
0210  2A0F     GOTO 0x20F
0211  2A12     GOTO 0x212
82:            }
0212  0008     RETURN
---  /firmware.X/ir_decoder.c  --------------------------------------------------------------------------
1:             /*
2:              * Copyright 2018 Google LLC
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            
17:            #include <stdint.h>
18:            #include <xc.h>
19:            
20:            #include "ir_decoder.h"
21:            
22:            #define MICROS_PER_CYCLE        140
23:            #define RESET_MICROS_PER_CYCLE  30
24:            #define START_MICROS            9000
25:            #define START_CYCLES            START_MICROS/MICROS_PER_CYCLE
26:            #define START_GAP_MICROS        4500
27:            #define START_GAP_CYCLES        START_GAP_MICROS/MICROS_PER_CYCLE
28:            #define BURST_MICROS            562
29:            #define BURST_CYCLES            BURST_MICROS/MICROS_PER_CYCLE
30:            #define ZERO_GAP_MICROS         562
31:            #define ZERO_GAP_CYCLES         ZERO_GAP_MICROS/MICROS_PER_CYCLE
32:            #define ONE_GAP_MICROS          1675
33:            #define ONE_GAP_CYCLES          ONE_GAP_MICROS/MICROS_PER_CYCLE
34:            
35:            // Reset timer 1 to trigger every MICROS_PER_CYCLE at 1MHz timer clock
36:            #define TIMER1_RESET() \
37:              do { \
38:                T1CONbits.TMR1ON = 0; \
39:                TMR1H = 255; \
40:                TMR1L = (255-MICROS_PER_CYCLE+RESET_MICROS_PER_CYCLE); \
41:                PIR1bits.TMR1IF = 0; \
42:                T1CONbits.TMR1ON = 1; \
43:              } while(0)
44:            
45:            #define IR_PIN PORTBbits.RB0
46:            
47:            #define BETWEEN(lo, val, hi) \
48:              (((lo) <= (val)) && ((val) <= (hi)))
49:            
50:            #define TIMING_MARGIN_START 15
51:            #define TIMING_MARGIN 2
52:            
53:            // Is a close to B?
54:            #define EQUALS_CLOSE(a, b) \
55:              BETWEEN((b)-TIMING_MARGIN, (a), (b)+TIMING_MARGIN)
56:            #define EQUALS_WIDE(a, b) \
57:              BETWEEN((b)-TIMING_MARGIN_START, (a), (b)+TIMING_MARGIN_START)
58:            
59:            typedef enum __PACK {
60:                STATE_IDLE,
61:                STATE_START,
62:                STATE_START_GAP,
63:                STATE_BURST,
64:                STATE_GAP,
65:            } ir_decoder_state_t;
66:            
67:            volatile uint32_t ir_data; // Data when valid
68:            volatile uint8_t ir_data_valid = 0; // Reader should reset this
69:            
70:            #define TRANSITION_STATE(new) \
71:                state_timer = 1; \
72:                decoder_state = (new)
73:            
74:            #define RESET_STATE() decoder_state = STATE_IDLE
75:            
76:            void timer1_interrupt_decoder() {
77:                /** Call from ISR when (TMR1IF && TMR1IE) */
78:                static volatile ir_decoder_state_t decoder_state = STATE_IDLE;
79:                static volatile uint8_t bit_count = 0;
80:                static volatile uint8_t state_timer = 0; // Time spent in current state
81:            
82:                TIMER1_RESET();
0021  1283     BCF STATUS, 0x5
0022  1010     BCF T1CON, 0x0
0023  30FF     MOVLW 0xFF
0024  008F     MOVWF TMR1H
0025  3091     MOVLW 0x91
0026  008E     MOVWF TMR1
0027  100C     BCF PIR1, 0x0
0028  1410     BSF T1CON, 0x0
83:            
84:                // Wait for previous data to be read
85:                if (ir_data_valid)
0029  0836     MOVF ir_data_valid, W
002A  1D03     BTFSS STATUS, 0x2
002B  0008     RETURN
002C  2951     GOTO 0x151
86:                    return;
87:            
88:                switch (decoder_state) {
0151  0835     MOVF decoder_state, W
0152  0084     MOVWF FSR
0153  3005     MOVLW 0x5
0154  0204     SUBWF FSR, W
0155  1803     BTFSC STATUS, 0x0
0156  0008     RETURN
0157  3002     MOVLW 0x2
0158  008A     MOVWF PCLATH
0159  3020     MOVLW 0x20
015A  0704     ADDWF FSR, W
015B  0082     MOVWF PCL
0220  282D     GOTO 0x2D
89:                    case STATE_IDLE:
90:                        // Idling
91:                        if (IR_PIN) // Still idle
002D  1806     BTFSC PORTB, 0x0
002E  0008     RETURN
92:                            return;
93:                        TRANSITION_STATE(STATE_START);
002F  3001     MOVLW 0x1
0030  00F0     MOVWF __pcstackCOMMON
0031  0870     MOVF __pcstackCOMMON, W
0032  00B3     MOVWF state_timer
0033  3001     MOVLW 0x1
0034  00F0     MOVWF __pcstackCOMMON
0035  0870     MOVF __pcstackCOMMON, W
0036  00B5     MOVWF decoder_state
94:                        bit_count = 0;
0037  01B4     CLRF bit_count
95:                        return;
0038  0008     RETURN
96:                    case STATE_START:
97:                        // In the start bit
98:                        if (!IR_PIN) {
0039  1806     BTFSC PORTB, 0x0
003A  2840     GOTO 0x40
99:                            state_timer++;
003B  3001     MOVLW 0x1
003C  00F0     MOVWF __pcstackCOMMON
003D  0870     MOVF __pcstackCOMMON, W
003E  07B3     ADDWF state_timer, F
100:                           return;
003F  0008     RETURN
101:                       }
102:                       // Check start burst length.
103:                       if (EQUALS_WIDE(state_timer, START_CYCLES)) {
0040  3031     MOVLW 0x31
0041  0233     SUBWF state_timer, W
0042  1C03     BTFSS STATUS, 0x0
0043  2851     GOTO 0x51
0044  3050     MOVLW 0x50
0045  0233     SUBWF state_timer, W
0046  1803     BTFSC STATUS, 0x0
0047  2851     GOTO 0x51
104:                           TRANSITION_STATE(STATE_START_GAP);
0048  3001     MOVLW 0x1
0049  00F0     MOVWF __pcstackCOMMON
004A  0870     MOVF __pcstackCOMMON, W
004B  00B3     MOVWF state_timer
004C  3002     MOVLW 0x2
004D  00F0     MOVWF __pcstackCOMMON
004E  0870     MOVF __pcstackCOMMON, W
004F  00B5     MOVWF decoder_state
105:                           return;
0050  0008     RETURN
106:                       }
107:                       // Not long enough for start burst
108:                       RESET_STATE();
0051  01B5     CLRF decoder_state
109:                       return;
0052  0008     RETURN
110:                   case STATE_START_GAP:
111:                       // In the gap
112:                       if (IR_PIN) {
0053  1C06     BTFSS PORTB, 0x0
0054  285A     GOTO 0x5A
113:                           state_timer++;
0055  3001     MOVLW 0x1
0056  00F0     MOVWF __pcstackCOMMON
0057  0870     MOVF __pcstackCOMMON, W
0058  07B3     ADDWF state_timer, F
114:                           return;
0059  0008     RETURN
115:                       }
116:                       if (!EQUALS_WIDE(state_timer, START_GAP_CYCLES)) {
005A  3011     MOVLW 0x11
005B  0233     SUBWF state_timer, W
005C  1C03     BTFSS STATUS, 0x0
005D  2862     GOTO 0x62
005E  3030     MOVLW 0x30
005F  0233     SUBWF state_timer, W
0060  1C03     BTFSS STATUS, 0x0
0061  2864     GOTO 0x64
117:                           RESET_STATE();
0062  01B5     CLRF decoder_state
118:                           return;
0063  0008     RETURN
119:                       }
120:                       // Have started data burst
121:                       TRANSITION_STATE(STATE_BURST);
0064  3001     MOVLW 0x1
0065  00F0     MOVWF __pcstackCOMMON
0066  0870     MOVF __pcstackCOMMON, W
0067  00B3     MOVWF state_timer
0068  3003     MOVLW 0x3
0069  00F0     MOVWF __pcstackCOMMON
006A  0870     MOVF __pcstackCOMMON, W
006B  00B5     MOVWF decoder_state
122:                       return;
006C  0008     RETURN
123:                   case STATE_BURST:
124:                       if (!IR_PIN) {
006D  1806     BTFSC PORTB, 0x0
006E  2874     GOTO 0x74
125:                           state_timer++;
006F  3001     MOVLW 0x1
0070  00F0     MOVWF __pcstackCOMMON
0071  0870     MOVF __pcstackCOMMON, W
0072  07B3     ADDWF state_timer, F
126:                           return;
0073  0008     RETURN
127:                       }
128:                       // Burst is over
129:                       if (!EQUALS_CLOSE(state_timer, BURST_CYCLES)) {
0074  3002     MOVLW 0x2
0075  0233     SUBWF state_timer, W
0076  1C03     BTFSS STATUS, 0x0
0077  287C     GOTO 0x7C
0078  3007     MOVLW 0x7
0079  0233     SUBWF state_timer, W
007A  1C03     BTFSS STATUS, 0x0
007B  287E     GOTO 0x7E
130:                           RESET_STATE();
007C  01B5     CLRF decoder_state
131:                       } else {
007D  0008     RETURN
132:                           TRANSITION_STATE(STATE_GAP);
007E  3001     MOVLW 0x1
007F  00F0     MOVWF __pcstackCOMMON
0080  0870     MOVF __pcstackCOMMON, W
0081  00B3     MOVWF state_timer
0082  3004     MOVLW 0x4
0083  00F0     MOVWF __pcstackCOMMON
0084  0870     MOVF __pcstackCOMMON, W
0085  00B5     MOVWF decoder_state
133:                       }
134:                       return;
0086  0008     RETURN
135:                   case STATE_GAP:
136:                       if (IR_PIN) {
0087  1C06     BTFSS PORTB, 0x0
0088  288E     GOTO 0x8E
137:                           state_timer++;
0089  3001     MOVLW 0x1
008A  00F0     MOVWF __pcstackCOMMON
008B  0870     MOVF __pcstackCOMMON, W
008C  07B3     ADDWF state_timer, F
138:                           return;
008D  0008     RETURN
139:                       }
140:                       if (EQUALS_CLOSE(state_timer, ZERO_GAP_CYCLES)) {
008E  3002     MOVLW 0x2
008F  0233     SUBWF state_timer, W
0090  1C03     BTFSS STATUS, 0x0
0091  28B8     GOTO 0xB8
0092  3007     MOVLW 0x7
0093  0233     SUBWF state_timer, W
0094  1803     BTFSC STATUS, 0x0
0095  28B8     GOTO 0xB8
141:                           // LSB first
142:                           ir_data &= ~(1ul << (31ul - bit_count));
0096  3001     MOVLW 0x1
0097  00F0     MOVWF __pcstackCOMMON
0098  3000     MOVLW 0x0
0099  00F1     MOVWF 0x71
009A  3000     MOVLW 0x0
009B  00F2     MOVWF 0x72
009C  3000     MOVLW 0x0
009D  00F3     MOVWF 0x73
009E  0334     DECF bit_count, W
009F  3AFF     XORLW 0xFF
00A0  3E1F     ADDLW 0x1F
00A1  3E01     ADDLW 0x1
00A2  28A8     GOTO 0xA8
00A3  1003     BCF STATUS, 0x0
00A4  0DF0     RLF __pcstackCOMMON, F
00A5  0DF1     RLF 0x71, F
00A6  0DF2     RLF 0x72, F
00A7  0DF3     RLF 0x73, F
00A8  3EFF     ADDLW 0xFF
00A9  1D03     BTFSS STATUS, 0x2
00AA  28A3     GOTO 0xA3
00AB  09F0     COMF __pcstackCOMMON, F
00AC  09F1     COMF 0x71, F
00AD  09F2     COMF 0x72, F
00AE  09F3     COMF 0x73, F
00AF  0870     MOVF __pcstackCOMMON, W
00B0  05AC     ANDWF ir_data, F
00B1  0871     MOVF 0x71, W
00B2  05AD     ANDWF 0x2D, F
00B3  0872     MOVF 0x72, W
00B4  05AE     ANDWF 0x2E, F
00B5  0873     MOVF 0x73, W
00B6  05AF     ANDWF 0x2F, F
143:                       } else if (EQUALS_CLOSE(state_timer, ONE_GAP_CYCLES)) {
00B7  28E0     GOTO 0xE0
00B8  3009     MOVLW 0x9
00B9  0233     SUBWF state_timer, W
00BA  1C03     BTFSS STATUS, 0x0
00BB  28DE     GOTO 0xDE
00BC  300E     MOVLW 0xE
00BD  0233     SUBWF state_timer, W
00BE  1803     BTFSC STATUS, 0x0
00BF  28DE     GOTO 0xDE
144:                           // LSB first
145:                           ir_data |= (1ul << (31ul - bit_count));
00C0  3001     MOVLW 0x1
00C1  00F0     MOVWF __pcstackCOMMON
00C2  3000     MOVLW 0x0
00C3  00F1     MOVWF 0x71
00C4  3000     MOVLW 0x0
00C5  00F2     MOVWF 0x72
00C6  3000     MOVLW 0x0
00C7  00F3     MOVWF 0x73
00C8  0334     DECF bit_count, W
00C9  3AFF     XORLW 0xFF
00CA  3E1F     ADDLW 0x1F
00CB  3E01     ADDLW 0x1
00CC  28D2     GOTO 0xD2
00CD  1003     BCF STATUS, 0x0
00CE  0DF0     RLF __pcstackCOMMON, F
00CF  0DF1     RLF 0x71, F
00D0  0DF2     RLF 0x72, F
00D1  0DF3     RLF 0x73, F
00D2  3EFF     ADDLW 0xFF
00D3  1D03     BTFSS STATUS, 0x2
00D4  28CD     GOTO 0xCD
00D5  0870     MOVF __pcstackCOMMON, W
00D6  04AC     IORWF ir_data, F
00D7  0871     MOVF 0x71, W
00D8  04AD     IORWF 0x2D, F
00D9  0872     MOVF 0x72, W
00DA  04AE     IORWF 0x2E, F
00DB  0873     MOVF 0x73, W
00DC  04AF     IORWF 0x2F, F
146:                       } else {
00DD  28E0     GOTO 0xE0
147:                           // Gone invalid
148:                           RESET_STATE();
00DE  01B5     CLRF decoder_state
149:                           return;
00DF  0008     RETURN
150:                       }
151:                       bit_count++;
00E0  3001     MOVLW 0x1
00E1  00F0     MOVWF __pcstackCOMMON
00E2  0870     MOVF __pcstackCOMMON, W
00E3  07B4     ADDWF bit_count, F
152:                       if (bit_count == 32) {
00E4  3020     MOVLW 0x20
00E5  0634     XORWF bit_count, W
00E6  1D03     BTFSS STATUS, 0x2
00E7  2948     GOTO 0x148
153:                           T1CONbits.TMR1ON = 0;
00E8  1010     BCF T1CON, 0x0
154:                           ir_data_valid = 1;
00E9  3001     MOVLW 0x1
00EA  00F0     MOVWF __pcstackCOMMON
00EB  0870     MOVF __pcstackCOMMON, W
00EC  00B6     MOVWF ir_data_valid
155:                           //debug
156:                           while(bit_count) {
00ED  1283     BCF STATUS, 0x5
00EE  0834     MOVF bit_count, W
00EF  1903     BTFSC STATUS, 0x2
00F0  2945     GOTO 0x145
157:                               PORTBbits.RB2 = 1;
00F1  1506     BSF PORTB, 0x2
158:                               for(int k=0;k<25;k++)
00F2  01F5     CLRF k
00F3  01F6     CLRF 0x76
00F4  0876     MOVF 0x76, W
00F5  3A80     XORLW 0x80
00F6  00FF     MOVWF 0x7F
00F7  3080     MOVLW 0x80
00F8  027F     SUBWF 0x7F, W
00F9  1D03     BTFSS STATUS, 0x2
00FA  28FD     GOTO 0xFD
00FB  3019     MOVLW 0x19
00FC  0275     SUBWF k, W
00FD  1803     BTFSC STATUS, 0x0
00FE  2911     GOTO 0x111
0100  3001     MOVLW 0x1
0101  07F5     ADDWF k, F
0102  1803     BTFSC STATUS, 0x0
0103  0AF6     INCF 0x76, F
0104  3000     MOVLW 0x0
0105  07F6     ADDWF 0x76, F
0106  0876     MOVF 0x76, W
0107  3A80     XORLW 0x80
0108  00FF     MOVWF 0x7F
0109  3080     MOVLW 0x80
010A  027F     SUBWF 0x7F, W
010B  1D03     BTFSS STATUS, 0x2
010C  290F     GOTO 0x10F
010D  3019     MOVLW 0x19
010E  0275     SUBWF k, W
010F  1C03     BTFSS STATUS, 0x0
0110  28FF     GOTO 0xFF
159:                                   NOP();
00FF  0000     NOP
160:                               PORTBbits.RB2 = ((ir_data>>(--bit_count)) & 1);
0111  1283     BCF STATUS, 0x5
0112  082C     MOVF ir_data, W
0113  00F0     MOVWF __pcstackCOMMON
0114  082D     MOVF 0x2D, W
0115  00F1     MOVWF 0x71
0116  082E     MOVF 0x2E, W
0117  00F2     MOVWF 0x72
0118  082F     MOVF 0x2F, W
0119  00F3     MOVWF 0x73
011A  3001     MOVLW 0x1
011B  02B4     SUBWF bit_count, F
011C  0A34     INCF bit_count, W
011D  2923     GOTO 0x123
011E  1003     BCF STATUS, 0x0
011F  0CF3     RRF 0x73, F
0120  0CF2     RRF 0x72, F
0121  0CF1     RRF 0x71, F
0122  0CF0     RRF __pcstackCOMMON, F
0123  3EFF     ADDLW 0xFF
0124  1D03     BTFSS STATUS, 0x2
0125  291E     GOTO 0x11E
0126  0870     MOVF __pcstackCOMMON, W
0127  3901     ANDLW 0x1
0128  00F4     MOVWF 0x74
0129  0DF4     RLF 0x74, F
012A  0DF4     RLF 0x74, F
012B  0806     MOVF PORTB, W
012C  0674     XORWF 0x74, W
012D  39FB     ANDLW 0xFB
012E  0674     XORWF 0x74, W
012F  0086     MOVWF PORTB
161:                               for(int k=0;k<100;k++)
0130  01F7     CLRF k
0131  01F8     CLRF 0x78
0132  0878     MOVF 0x78, W
0133  3A80     XORLW 0x80
0134  00FF     MOVWF 0x7F
0135  3080     MOVLW 0x80
0136  027F     SUBWF 0x7F, W
0137  1D03     BTFSS STATUS, 0x2
0138  293B     GOTO 0x13B
0139  3064     MOVLW 0x64
013A  0277     SUBWF k, W
013B  1803     BTFSC STATUS, 0x0
013C  28ED     GOTO 0xED
013E  3001     MOVLW 0x1
013F  07F7     ADDWF k, F
0140  1803     BTFSC STATUS, 0x0
0141  0AF8     INCF 0x78, F
0142  3000     MOVLW 0x0
0143  07F8     ADDWF 0x78, F
0144  2932     GOTO 0x132
162:                                   NOP();
013D  0000     NOP
163:                           }
164:                           T1CONbits.TMR1ON = 1;
0145  1410     BSF T1CON, 0x0
165:                           RESET_STATE();
0146  01B5     CLRF decoder_state
166:                       } else {
0147  0008     RETURN
167:                           TRANSITION_STATE(STATE_BURST);
0148  3001     MOVLW 0x1
0149  00F0     MOVWF __pcstackCOMMON
014A  0870     MOVF __pcstackCOMMON, W
014B  00B3     MOVWF state_timer
014C  3003     MOVLW 0x3
014D  00F0     MOVWF __pcstackCOMMON
014E  0870     MOVF __pcstackCOMMON, W
014F  00B5     MOVWF decoder_state
168:                       }
169:                       return;
170:               }
0150  0008     RETURN
171:           }
015C  0008     RETURN
172:           
173:           void setup_ir_decoder() {
174:               // Setup IR PIN as input
175:               TRISBbits.TRISB0 = 1;
01C5  1683     BSF STATUS, 0x5
01C6  1406     BSF PORTB, 0x0
176:               // Setup the timer
177:               T1CONbits.T1SYNC = 1; // bit 2 Timer1 External Clock Input Synchronization Control bit...1 = Do not synchronize external clock input
01C7  1283     BCF STATUS, 0x5
01C8  1510     BSF T1CON, 0x2
178:               PIE1bits.TMR1IE = 1; // Timer 1 triggers interrupt
01C9  1683     BSF STATUS, 0x5
01CA  140C     BSF PIR1, 0x0
179:               INTCONbits.PEIE = 1; // Peripheral interrupts
01CB  170B     BSF INTCON, 0x6
180:               INTCONbits.GIE = 1; // Global interrupts.
01CC  178B     BSF INTCON, 0x7
181:               TIMER1_RESET();
01CD  1283     BCF STATUS, 0x5
01CE  1010     BCF T1CON, 0x0
01CF  30FF     MOVLW 0xFF
01D0  008F     MOVWF TMR1H
01D1  3091     MOVLW 0x91
01D2  008E     MOVWF TMR1
01D3  100C     BCF PIR1, 0x0
01D4  1410     BSF T1CON, 0x0
182:               // debugging
183:               TRISBbits.TRISB2 = 0;
01D5  1683     BSF STATUS, 0x5
01D6  1106     BCF PORTB, 0x2
184:           }
01D7  0008     RETURN
185:           
