Disassembly Listing for firmware_dev
Generated From:
/firmware.X/dist/default/production/firmware.X.production.elf
May 18, 2018 11:31:02 PM

---  /firmware.X/main.c  --------------------------------------------------------------------------------
1:             /*
2:              * File:   main.c
3:              * Author: David
4:              *
5:              * Created on May 15, 2018, 3:16 AM
6:              */
7:             
8:             // CONFIG
9:             #pragma config FOSC = XT        // Oscillator Selection bits (XT oscillator)
10:            #pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT enabled)
11:            #pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
12:            #pragma config BOREN = OFF      // Brown-out Reset Enable bit (BOR disabled)
13:            #pragma config BODENV = 40      // Brown-out Reset Voltage bit (VBOR set to 4.0V)
14:            #pragma config CP = OFF         // Code Protect (Program memory code protection is disabled)
15:            
16:            #include <xc.h>
17:            
18:            #include "ir_decoder.h"
19:            #include "leds.h"
20:            
21:            volatile uint8_t move_leds = 1;
22:            
23:            static void interrupt ISR(void) {
0004  00FE     MOVWF 0x7E
24:                /*
25:                if (INTCONbits.T0IF) {
26:                    timer0_interrupt();
27:                }
28:                if (ir_data_valid) {
29:                    move_leds ^= 1;
30:                    ir_data_valid = 0;
31:                }
32:                */
33:                if (PIR1bits.TMR1IF && PIE1bits.TMR1IE) {
0190  1C0C     BTFSS PIR1, 0x0
0191  2996     GOTO 0x196
0192  1683     BSF STATUS, 0x5
0193  1C0C     BTFSS PIR1, 0x0
0194  2996     GOTO 0x196
34:                    timer1_interrupt_decoder();
0195  201D     CALL 0x1D
35:                }
36:            }
0196  1283     BCF STATUS, 0x5
0197  082A     MOVF 0x2A, W
0198  00FF     MOVWF 0x7F
0199  0829     MOVF 0x29, W
019A  008A     MOVWF PCLATH
019B  0828     MOVF 0x28, W
019C  0084     MOVWF FSR
019D  0E27     SWAPF __pcstackBANK0, W
019E  0083     MOVWF STATUS
019F  0EFE     SWAPF 0x7E, F
01A0  0E7E     SWAPF 0x7E, W
01A1  0009     RETFIE
37:            
38:            void main(void) {
39:                //timer0_setup();
40:                setup_ir_decoder();
01C7  21A2     CALL 0x1A2
41:                
42:                for(;;){}
01C8  29C8     GOTO 0x1C8
43:            }
---  /firmware.X/leds.c  --------------------------------------------------------------------------------
1:             #include <stdint.h>
2:             
3:             #include <xc.h>
4:             
5:             #include "leds.h"
6:             
7:             #define LED_RED_LEFT()          leda_on(0, 0)
8:             #define LED_RED_RIGHT()         leda_on(0, 1)
9:             #define LED_YELLOW_LEFT()       leda_on(2, 0)
10:            #define LED_YELLOW_RIGHT()      leda_on(2, 1)
11:            #define LED_GREEN_LEFT()        ledb_on(3, 0)
12:            #define LED_GREEN_RIGHT()       leda_on(3, 0)
13:            #define LED_BLUE_LEFT()         ledb_on(3, 1)
14:            #define LED_BLUE_RIGHT()        leda_on(3, 1)
15:            
16:            static inline void all_off();
17:            static inline void leda_on(uint8_t pos, uint8_t dir);
18:            static inline void ledb_on(uint8_t pos, uint8_t dir);
19:            
20:            /*
21:             * Turn on exactly one LED
22:             */
23:            void exactly_on(uint8_t which) {
00FD  00F4     MOVWF which
24:                all_off();
00FE  21BB     CALL 0x1BB
25:                switch (which) {
00FF  2924     GOTO 0x124
0124  0874     MOVF which, W
0125  0084     MOVWF FSR
0126  3008     MOVLW 0x8
0127  0204     SUBWF FSR, W
0128  1803     BTFSC STATUS, 0x0
0129  0008     RETURN
012A  3001     MOVLW 0x1
012B  008A     MOVWF PCLATH
012C  30B3     MOVLW 0xB3
012D  0704     ADDWF FSR, W
012E  0082     MOVWF PCL
01B3  2900     GOTO 0x100
26:                    case 0:
27:                        LED_RED_LEFT();
0100  01F0     CLRF __pcstackCOMMON
0101  3000     MOVLW 0x0
0102  2160     CALL 0x160
28:                        break;
0103  0008     RETURN
29:                    case 1:
30:                        LED_YELLOW_LEFT();
0104  01F0     CLRF __pcstackCOMMON
0105  3002     MOVLW 0x2
0106  2160     CALL 0x160
31:                        break;
0107  0008     RETURN
32:                    case 2:
33:                        LED_GREEN_LEFT();
0108  01F0     CLRF __pcstackCOMMON
0109  3003     MOVLW 0x3
010A  2130     CALL 0x130
34:                        break;
010B  0008     RETURN
35:                    case 3:
36:                        LED_BLUE_LEFT();
010C  01F0     CLRF __pcstackCOMMON
010D  0AF0     INCF __pcstackCOMMON, F
010E  3003     MOVLW 0x3
010F  2130     CALL 0x130
37:                        break;
0110  0008     RETURN
38:                    case 4:
39:                        LED_RED_RIGHT();
0111  01F0     CLRF __pcstackCOMMON
0112  0AF0     INCF __pcstackCOMMON, F
0113  3000     MOVLW 0x0
0114  2160     CALL 0x160
40:                        break;
0115  0008     RETURN
41:                    case 5:
42:                        LED_YELLOW_RIGHT();
0116  01F0     CLRF __pcstackCOMMON
0117  0AF0     INCF __pcstackCOMMON, F
0118  3002     MOVLW 0x2
0119  2160     CALL 0x160
43:                        break;
011A  0008     RETURN
44:                    case 6:
45:                        LED_GREEN_RIGHT();
011B  01F0     CLRF __pcstackCOMMON
011C  3003     MOVLW 0x3
011D  2160     CALL 0x160
46:                        break;
011E  0008     RETURN
47:                    case 7:
48:                        LED_BLUE_RIGHT();
011F  01F0     CLRF __pcstackCOMMON
0120  0AF0     INCF __pcstackCOMMON, F
0121  3003     MOVLW 0x3
0122  2160     CALL 0x160
49:                        break;
50:                }    
0123  0008     RETURN
51:            }
012F  0008     RETURN
52:            
53:            /*
54:             * Turn all LEDs off
55:             */
56:            static inline void all_off() {
57:                TRISA |= 1 | (1 << 2) | (1 << 3);
01BB  300D     MOVLW 0xD
01BC  00F0     MOVWF __pcstackCOMMON
01BD  0870     MOVF __pcstackCOMMON, W
01BE  1683     BSF STATUS, 0x5
01BF  0485     IORWF PORTA, F
58:                TRISB |= (1 << 3);
01C0  1586     BSF PORTB, 0x3
59:            }
01C1  0008     RETURN
60:            
61:            /*
62:             * Turn a LED on on PORTA
63:             */
64:            static inline void leda_on(uint8_t pos, uint8_t dir) {
0160  00F3     MOVWF pos
65:                if (dir)
0161  0870     MOVF __pcstackCOMMON, W
0162  1903     BTFSC STATUS, 0x2
0163  2973     GOTO 0x173
66:                    PORTA |= (1u<<pos);
0164  3001     MOVLW 0x1
0165  00F1     MOVWF 0x71
0166  0A73     INCF pos, W
0167  296A     GOTO 0x16A
0168  1003     BCF STATUS, 0x0
0169  0DF1     RLF 0x71, F
016A  3EFF     ADDLW 0xFF
016B  1D03     BTFSS STATUS, 0x2
016C  2968     GOTO 0x168
016D  0871     MOVF 0x71, W
016E  00F2     MOVWF 0x72
016F  0872     MOVF 0x72, W
0170  1283     BCF STATUS, 0x5
0171  0485     IORWF PORTA, F
0172  2982     GOTO 0x182
67:                else
68:                    PORTA &= ~(1u<<pos);
0173  3001     MOVLW 0x1
0174  00F1     MOVWF 0x71
0175  0A73     INCF pos, W
0176  2979     GOTO 0x179
0177  1003     BCF STATUS, 0x0
0178  0DF1     RLF 0x71, F
0179  3EFF     ADDLW 0xFF
017A  1D03     BTFSS STATUS, 0x2
017B  2977     GOTO 0x177
017C  0871     MOVF 0x71, W
017D  3AFF     XORLW 0xFF
017E  00F2     MOVWF 0x72
017F  0872     MOVF 0x72, W
0180  1283     BCF STATUS, 0x5
0181  0585     ANDWF PORTA, F
69:                TRISA = ~(1u<<pos);   
0182  3001     MOVLW 0x1
0183  00F1     MOVWF 0x71
0184  0A73     INCF pos, W
0185  2988     GOTO 0x188
0186  1003     BCF STATUS, 0x0
0187  0DF1     RLF 0x71, F
0188  3EFF     ADDLW 0xFF
0189  1D03     BTFSS STATUS, 0x2
018A  2986     GOTO 0x186
018B  0871     MOVF 0x71, W
018C  3AFF     XORLW 0xFF
018D  1683     BSF STATUS, 0x5
018E  0085     MOVWF PORTA
70:            }
018F  0008     RETURN
71:            
72:            /*
73:             * Turn a LED on on PORTB
74:             */
75:            static inline void ledb_on(uint8_t pos, uint8_t dir) {
0130  00F3     MOVWF pos
76:                if (dir)
0131  0870     MOVF __pcstackCOMMON, W
0132  1903     BTFSC STATUS, 0x2
0133  2943     GOTO 0x143
77:                    PORTB |= (1u<<pos);
0134  3001     MOVLW 0x1
0135  00F1     MOVWF 0x71
0136  0A73     INCF pos, W
0137  293A     GOTO 0x13A
0138  1003     BCF STATUS, 0x0
0139  0DF1     RLF 0x71, F
013A  3EFF     ADDLW 0xFF
013B  1D03     BTFSS STATUS, 0x2
013C  2938     GOTO 0x138
013D  0871     MOVF 0x71, W
013E  00F2     MOVWF 0x72
013F  0872     MOVF 0x72, W
0140  1283     BCF STATUS, 0x5
0141  0486     IORWF PORTB, F
0142  2952     GOTO 0x152
78:                else
79:                    PORTB &= ~(1u<<pos);
0143  3001     MOVLW 0x1
0144  00F1     MOVWF 0x71
0145  0A73     INCF pos, W
0146  2949     GOTO 0x149
0147  1003     BCF STATUS, 0x0
0148  0DF1     RLF 0x71, F
0149  3EFF     ADDLW 0xFF
014A  1D03     BTFSS STATUS, 0x2
014B  2947     GOTO 0x147
014C  0871     MOVF 0x71, W
014D  3AFF     XORLW 0xFF
014E  00F2     MOVWF 0x72
014F  0872     MOVF 0x72, W
0150  1283     BCF STATUS, 0x5
0151  0586     ANDWF PORTB, F
80:                TRISB = ~(1u<<pos);
0152  3001     MOVLW 0x1
0153  00F1     MOVWF 0x71
0154  0A73     INCF pos, W
0155  2958     GOTO 0x158
0156  1003     BCF STATUS, 0x0
0157  0DF1     RLF 0x71, F
0158  3EFF     ADDLW 0xFF
0159  1D03     BTFSS STATUS, 0x2
015A  2956     GOTO 0x156
015B  0871     MOVF 0x71, W
015C  3AFF     XORLW 0xFF
015D  1683     BSF STATUS, 0x5
015E  0086     MOVWF PORTB
81:            }
015F  0008     RETURN
82:            
83:            void timer0_interrupt(void) {
84:                static volatile uint8_t pos = 0;
85:                pos++;
86:                pos &= 7;
87:                all_off();
88:                switch (pos) {
89:                    case 0:
90:                        LED_RED_LEFT();
91:                        break;
92:                    case 1:
93:                        LED_YELLOW_LEFT();
94:                        break;
95:                    case 2:
96:                        LED_GREEN_LEFT();
97:                        break;
98:                    case 3:
99:                        LED_BLUE_LEFT();
100:                       break;
101:                   case 4:
102:                       LED_RED_RIGHT();
103:                       break;
104:                   case 5:
105:                       LED_YELLOW_RIGHT();
106:                       break;
107:                   case 6:
108:                       LED_GREEN_RIGHT();
109:                       break;
110:                   case 7:
111:                       LED_BLUE_RIGHT();
112:                       break;
113:               }
114:               INTCONbits.T0IF = 0;  // Clear flag
115:           }
116:           
117:           void timer0_setup() {
118:               OPTION_REGbits.PSA   = 0;      // Prescaler
119:               OPTION_REGbits.PS    = 0b111;  // 1:256 Prescaler
120:               OPTION_REGbits.T0CS  = 0;      // Source = oscillator
121:               INTCONbits.T0IF      = 0;      // Clear flag.
122:               INTCONbits.T0IE      = 1;      // Enable timer0 interrupts
123:               INTCONbits.GIE       = 1;      // Enable global interrupts
124:           }
---  /firmware.X/ir_decoder.c  --------------------------------------------------------------------------
1:             #include <stdint.h>
2:             #include <xc.h>
3:             
4:             #include "ir_decoder.h"
5:             #include "leds.h" // For debug signalling only
6:             
7:             #define MICROS_PER_CYCLE      140
8:             #define START_MICROS          9000
9:             #define START_CYCLES          START_MICROS/MICROS_PER_CYCLE
10:            #define START_GAP_MICROS      4500
11:            #define START_GAP_CYCLES      START_GAP_MICROS/MICROS_PER_CYCLE
12:            #define BURST_MICROS          562
13:            #define BURST_CYCLES          BURST_MICROS/MICROS_PER_CYCLE
14:            #define ZERO_GAP_MICROS       562
15:            #define ZERO_GAP_CYCLES       ZERO_GAP_MICROS/MICROS_PER_CYCLE
16:            #define ONE_GAP_MICROS        1675
17:            #define ONE_GAP_CYCLES        ONE_GAP_MICROS/MICROS_PER_CYCLE
18:            
19:            // Reset timer 1 to trigger every MICROS_PER_CYCLE at 1MHz timer clock
20:            #define TIMER1_RESET() \
21:              do { \
22:                TMR1H = 255; \
23:                TMR1L = (255-MICROS_PER_CYCLE); \
24:                PIR1bits.TMR1IF = 0; \
25:              } while(0)
26:            
27:            #define IR_PIN PORTBbits.RB0
28:            
29:            #define BETWEEN(lo, val, hi) \
30:              (((lo) <= (val)) && ((val) <= (hi)))
31:            
32:            #define TIMING_MARGIN_PERCENT 20
33:            
34:            // Is a close to B?
35:            #define EQUALS_CLOSE(a, b) \
36:              BETWEEN(((b)*(100-TIMING_MARGIN_PERCENT)/100), (a), (b)*(100+TIMING_MARGIN_PERCENT)/100)
37:            
38:            typedef enum __PACK {
39:              STATE_IDLE,
40:              STATE_START,
41:              STATE_START_GAP,
42:              STATE_BURST,
43:              STATE_GAP,
44:            } ir_decoder_state_t;
45:            
46:            volatile uint32_t ir_data;  // Data when valid
47:            volatile uint8_t ir_data_valid = 0;  // Reader should reset this
48:            
49:            void timer1_interrupt_decoder() {
50:              /** Call from ISR when (TMR1IF && TMR1IE) */
51:              static volatile ir_decoder_state_t decoder_state = STATE_IDLE;
52:              static volatile uint8_t bit_count = 0;
53:              static volatile uint8_t state_timer = 0;  // Time spent in current state
54:            
55:              TIMER1_RESET();
001D  30FF     MOVLW 0xFF
001E  1283     BCF STATUS, 0x5
001F  008F     MOVWF TMR1H
0020  3073     MOVLW 0x73
0021  008E     MOVWF TMR1
0022  100C     BCF PIR1, 0x0
56:            
57:              // Wait for previous data to be read
58:              if(ir_data_valid)
0023  0826     MOVF ir_data_valid, W
0024  1D03     BTFSS STATUS, 0x2
0025  0008     RETURN
0026  28F1     GOTO 0xF1
59:                return;
60:            
61:              switch (decoder_state) {
00F1  0825     MOVF decoder_state, W
00F2  0084     MOVWF FSR
00F3  3005     MOVLW 0x5
00F4  0204     SUBWF FSR, W
00F5  1803     BTFSC STATUS, 0x0
00F6  0008     RETURN
00F7  3001     MOVLW 0x1
00F8  008A     MOVWF PCLATH
00F9  30C2     MOVLW 0xC2
00FA  0704     ADDWF FSR, W
00FB  0082     MOVWF PCL
01C2  2827     GOTO 0x27
62:                case STATE_IDLE:
63:                  // Idling
64:                  if (IR_PIN) // Still idle
0027  1806     BTFSC PORTB, 0x0
0028  0008     RETURN
65:                    return;
66:                  decoder_state = STATE_START;
0029  3001     MOVLW 0x1
002A  00F5     MOVWF 0x75
002B  0875     MOVF 0x75, W
002C  00A5     MOVWF decoder_state
67:                  state_timer = 1;
002D  3001     MOVLW 0x1
002E  00F5     MOVWF 0x75
002F  0875     MOVF 0x75, W
0030  00FC     MOVWF __pbssCOMMON
68:                  bit_count = 0;
0031  01FD     CLRF bit_count
69:                  return;
0032  0008     RETURN
70:                case STATE_START:
71:                  // In the start bit
72:                  exactly_on(1);
0033  3001     MOVLW 0x1
0034  20FD     CALL 0xFD
73:                  if (!IR_PIN) {
0035  1283     BCF STATUS, 0x5
0036  1806     BTFSC PORTB, 0x0
0037  283D     GOTO 0x3D
74:                    state_timer++;
0038  3001     MOVLW 0x1
0039  00F5     MOVWF 0x75
003A  0875     MOVF 0x75, W
003B  07FC     ADDWF __pbssCOMMON, F
75:                    return;
003C  0008     RETURN
76:                  }
77:                  // Check start burst length.
78:                  if (EQUALS_CLOSE(state_timer, START_CYCLES)) {
003D  3033     MOVLW 0x33
003E  027C     SUBWF __pbssCOMMON, W
003F  1C03     BTFSS STATUS, 0x0
0040  284B     GOTO 0x4B
0041  304D     MOVLW 0x4D
0042  027C     SUBWF __pbssCOMMON, W
0043  1803     BTFSC STATUS, 0x0
0044  284B     GOTO 0x4B
79:                    decoder_state = STATE_START_GAP;
0045  3002     MOVLW 0x2
0046  00F5     MOVWF 0x75
0047  0875     MOVF 0x75, W
0048  00A5     MOVWF decoder_state
80:                    state_timer=0;
0049  01FC     CLRF __pbssCOMMON
81:                    return;
004A  0008     RETURN
82:                  }
83:                  // Not long enough for start burst
84:                  decoder_state = STATE_IDLE;
004B  01A5     CLRF decoder_state
85:                  return;
004C  0008     RETURN
86:                case STATE_START_GAP:
87:                  // In the gap
88:                  exactly_on(2);
004D  3002     MOVLW 0x2
004E  20FD     CALL 0xFD
89:                  if (IR_PIN) {
004F  1283     BCF STATUS, 0x5
0050  1C06     BTFSS PORTB, 0x0
0051  2857     GOTO 0x57
90:                    state_timer++;
0052  3001     MOVLW 0x1
0053  00F5     MOVWF 0x75
0054  0875     MOVF 0x75, W
0055  07FC     ADDWF __pbssCOMMON, F
91:                    return;
0056  0008     RETURN
92:                  }
93:                  if (!EQUALS_CLOSE(state_timer, START_GAP_CYCLES)) {
0057  3019     MOVLW 0x19
0058  027C     SUBWF __pbssCOMMON, W
0059  1C03     BTFSS STATUS, 0x0
005A  285F     GOTO 0x5F
005B  3027     MOVLW 0x27
005C  027C     SUBWF __pbssCOMMON, W
005D  1C03     BTFSS STATUS, 0x0
005E  2861     GOTO 0x61
94:                    decoder_state = STATE_IDLE;
005F  01A5     CLRF decoder_state
95:                    return;
0060  0008     RETURN
96:                  }
97:                  // Have started data burst
98:                  state_timer = 0;
0061  01FC     CLRF __pbssCOMMON
99:                  decoder_state = STATE_BURST;
0062  3003     MOVLW 0x3
0063  00F5     MOVWF 0x75
0064  0875     MOVF 0x75, W
0065  00A5     MOVWF decoder_state
100:                 return;
0066  0008     RETURN
101:               case STATE_BURST:
102:                 exactly_on(3);
0067  3003     MOVLW 0x3
0068  20FD     CALL 0xFD
103:                 if (!IR_PIN) {
0069  1283     BCF STATUS, 0x5
006A  1806     BTFSC PORTB, 0x0
006B  2871     GOTO 0x71
104:                   state_timer++;
006C  3001     MOVLW 0x1
006D  00F5     MOVWF 0x75
006E  0875     MOVF 0x75, W
006F  07FC     ADDWF __pbssCOMMON, F
105:                   return;
0070  0008     RETURN
106:                 }
107:                 // Burst is over
108:                 if (!EQUALS_CLOSE(state_timer, BURST_CYCLES)) {
0071  3003     MOVLW 0x3
0072  027C     SUBWF __pbssCOMMON, W
0073  1C03     BTFSS STATUS, 0x0
0074  2879     GOTO 0x79
0075  3005     MOVLW 0x5
0076  027C     SUBWF __pbssCOMMON, W
0077  1C03     BTFSS STATUS, 0x0
0078  287B     GOTO 0x7B
109:                   decoder_state = STATE_IDLE;
0079  01A5     CLRF decoder_state
110:                 } else {
007A  0008     RETURN
111:                   decoder_state = STATE_GAP;
007B  3004     MOVLW 0x4
007C  00F5     MOVWF 0x75
007D  0875     MOVF 0x75, W
007E  00A5     MOVWF decoder_state
112:                   state_timer = 0;
007F  01FC     CLRF __pbssCOMMON
113:                 }
114:                 return;
0080  0008     RETURN
115:               case STATE_GAP:
116:                 exactly_on(4);
0081  3004     MOVLW 0x4
0082  20FD     CALL 0xFD
117:                 if (IR_PIN) {
0083  1283     BCF STATUS, 0x5
0084  1C06     BTFSS PORTB, 0x0
0085  288B     GOTO 0x8B
118:                   state_timer++;
0086  3001     MOVLW 0x1
0087  00F5     MOVWF 0x75
0088  0875     MOVF 0x75, W
0089  07FC     ADDWF __pbssCOMMON, F
119:                   return;
008A  0008     RETURN
120:                 }
121:                 if (EQUALS_CLOSE(state_timer, ZERO_GAP_CYCLES)) {
008B  3003     MOVLW 0x3
008C  027C     SUBWF __pbssCOMMON, W
008D  1C03     BTFSS STATUS, 0x0
008E  28B3     GOTO 0xB3
008F  3005     MOVLW 0x5
0090  027C     SUBWF __pbssCOMMON, W
0091  1803     BTFSC STATUS, 0x0
0092  28B3     GOTO 0xB3
122:                   // LSB first
123:                   ir_data &= ~(1u << (31u-bit_count));
0093  037D     DECF bit_count, W
0094  3AFF     XORLW 0xFF
0095  3E1F     ADDLW 0x1F
0096  00F5     MOVWF 0x75
0097  0AF5     INCF 0x75, F
0098  3001     MOVLW 0x1
0099  00F6     MOVWF 0x76
009A  3000     MOVLW 0x0
009B  00F7     MOVWF 0x77
009C  28A0     GOTO 0xA0
009D  1003     BCF STATUS, 0x0
009E  0DF6     RLF 0x76, F
009F  0DF7     RLF 0x77, F
00A0  0BF5     DECFSZ 0x75, F
00A1  289D     GOTO 0x9D
00A2  09F6     COMF 0x76, F
00A3  09F7     COMF 0x77, F
00A4  0876     MOVF 0x76, W
00A5  00F8     MOVWF 0x78
00A6  0877     MOVF 0x77, W
00A7  00F9     MOVWF 0x79
00A8  01FA     CLRF 0x7A
00A9  01FB     CLRF 0x7B
00AA  0878     MOVF 0x78, W
00AB  05A0     ANDWF ir_data, F
00AC  0879     MOVF 0x79, W
00AD  05A1     ANDWF 0x21, F
00AE  087A     MOVF 0x7A, W
00AF  05A2     ANDWF 0x22, F
00B0  087B     MOVF 0x7B, W
00B1  05A3     ANDWF 0x23, F
124:                 } else if (EQUALS_CLOSE(state_timer, ONE_GAP_CYCLES)) {
00B2  28DB     GOTO 0xDB
00B3  3008     MOVLW 0x8
00B4  027C     SUBWF __pbssCOMMON, W
00B5  1C03     BTFSS STATUS, 0x0
00B6  28D9     GOTO 0xD9
00B7  300E     MOVLW 0xE
00B8  027C     SUBWF __pbssCOMMON, W
00B9  1803     BTFSC STATUS, 0x0
00BA  28D9     GOTO 0xD9
125:                   // LSB first
126:                   ir_data |= (1u << (31u-bit_count));
00BB  037D     DECF bit_count, W
00BC  3AFF     XORLW 0xFF
00BD  3E1F     ADDLW 0x1F
00BE  00F5     MOVWF 0x75
00BF  0AF5     INCF 0x75, F
00C0  3001     MOVLW 0x1
00C1  00F6     MOVWF 0x76
00C2  3000     MOVLW 0x0
00C3  00F7     MOVWF 0x77
00C4  28C8     GOTO 0xC8
00C5  1003     BCF STATUS, 0x0
00C6  0DF6     RLF 0x76, F
00C7  0DF7     RLF 0x77, F
00C8  0BF5     DECFSZ 0x75, F
00C9  28C5     GOTO 0xC5
00CA  0876     MOVF 0x76, W
00CB  00F8     MOVWF 0x78
00CC  0877     MOVF 0x77, W
00CD  00F9     MOVWF 0x79
00CE  01FA     CLRF 0x7A
00CF  01FB     CLRF 0x7B
00D0  0878     MOVF 0x78, W
00D1  04A0     IORWF ir_data, F
00D2  0879     MOVF 0x79, W
00D3  04A1     IORWF 0x21, F
00D4  087A     MOVF 0x7A, W
00D5  04A2     IORWF 0x22, F
00D6  087B     MOVF 0x7B, W
00D7  04A3     IORWF 0x23, F
127:                 } else {
00D8  28DB     GOTO 0xDB
128:                   // Gone invalid
129:                   decoder_state = STATE_IDLE;
00D9  01A5     CLRF decoder_state
130:                   return;
00DA  0008     RETURN
131:                 }
132:                 // Found a valid bit
133:                 bit_count++;
00DB  3001     MOVLW 0x1
00DC  00F5     MOVWF 0x75
00DD  0875     MOVF 0x75, W
00DE  07FD     ADDWF bit_count, F
134:                 if (bit_count == 32) {
00DF  3020     MOVLW 0x20
00E0  067D     XORWF bit_count, W
00E1  1D03     BTFSS STATUS, 0x2
00E2  28EB     GOTO 0xEB
135:                   ir_data_valid = 1;
00E3  3001     MOVLW 0x1
00E4  00F5     MOVWF 0x75
00E5  0875     MOVF 0x75, W
00E6  00A6     MOVWF ir_data_valid
136:                   decoder_state = STATE_IDLE;
00E7  01A5     CLRF decoder_state
137:                   exactly_on(5);
00E8  3005     MOVLW 0x5
00E9  20FD     CALL 0xFD
138:                 } else {
00EA  0008     RETURN
139:                   decoder_state = STATE_BURST;
00EB  3003     MOVLW 0x3
00EC  00F5     MOVWF 0x75
00ED  0875     MOVF 0x75, W
00EE  1283     BCF STATUS, 0x5
00EF  00A5     MOVWF decoder_state
140:                 }
141:                 return;
142:             }
00F0  0008     RETURN
143:           }
00FC  0008     RETURN
144:           
145:           void setup_ir_decoder() {
146:               // Setup IR PIN as input
147:               TRISBbits.TRISB0 = 1;
01A2  1683     BSF STATUS, 0x5
01A3  1406     BSF PORTB, 0x0
148:               // Setup the timer
149:               T1CONbits.T1OSCEN = 1;   // bit 3 Timer1 Oscillator Enable Control bit 1 = on
01A4  1283     BCF STATUS, 0x5
01A5  1590     BSF T1CON, 0x3
150:               T1CONbits.T1SYNC = 1;    // bit 2 Timer1 External Clock Input Synchronization Control bit...1 = Do not synchronize external clock input
01A6  1510     BSF T1CON, 0x2
151:               T1CONbits.TMR1ON = 1;    // bit 0 enables timer
01A7  1410     BSF T1CON, 0x0
152:               PIE1bits.TMR1IE = 1;     // Timer 1 triggers interrupt
01A8  1683     BSF STATUS, 0x5
01A9  140C     BSF PIR1, 0x0
153:               INTCONbits.PEIE = 1;     // Peripheral interrupts
01AA  170B     BSF INTCON, 0x6
154:               INTCONbits.GIE = 1;      // Global interrupts.
01AB  178B     BSF INTCON, 0x7
155:               TIMER1_RESET();
01AC  30FF     MOVLW 0xFF
01AD  1283     BCF STATUS, 0x5
01AE  008F     MOVWF TMR1H
01AF  3073     MOVLW 0x73
01B0  008E     MOVWF TMR1
01B1  100C     BCF PIR1, 0x0
01B2  0008     RETURN
156:           }
157:           
