

Microchip Technology PIC LITE Macro Assembler V1.45 build -152302408 
                                                                                               Tue May 15 04:05:04 2018

Microchip Technology Omniscient Code Generator v1.45 (Free mode) build 201711160504
     1                           	processor	16F716
     2                           	opt	pw 120
     3                           	opt	lm
     4                           	psect	cinit,global,class=CODE,merge=1,delta=2
     5                           	psect	bssCOMMON,global,class=COMMON,space=1,delta=1
     6                           	psect	bssBANK0,global,class=BANK0,space=1,delta=1
     7                           	psect	cstackCOMMON,global,class=COMMON,space=1,delta=1
     8                           	psect	cstackBANK0,global,class=BANK0,space=1,delta=1
     9                           	psect	maintext,global,class=CODE,split=1,delta=2
    10                           	psect	text1,local,class=CODE,merge=1,delta=2
    11                           	psect	text2,local,class=CODE,merge=1,delta=2
    12                           	psect	intentry,global,class=CODE,delta=2
    13                           	psect	text3,local,class=CODE,merge=1,delta=2
    14                           	psect	swtext1,local,class=CONST,delta=2
    15                           	dabs	1,0x7E,2
    16  0000                     
    17                           ; Version 1.45
    18                           ; Generated 16/11/2017 GMT
    19                           ; 
    20                           ; Copyright Â© 2017, Microchip Technology Inc. and its subsidiaries ("Microchip")
    21                           ; All rights reserved.
    22                           ; 
    23                           ; This software is developed by Microchip Technology Inc. and its subsidiaries ("Microch
      +                          ip").
    24                           ; 
    25                           ; Redistribution and use in source and binary forms, with or without modification, are
    26                           ; permitted provided that the following conditions are met:
    27                           ; 
    28                           ;     1. Redistributions of source code must retain the above copyright notice, this lis
      +                          t of
    29                           ;        conditions and the following disclaimer.
    30                           ; 
    31                           ;     2. Redistributions in binary form must reproduce the above copyright notice, this 
      +                          list
    32                           ;        of conditions and the following disclaimer in the documentation and/or other
    33                           ;        materials provided with the distribution.
    34                           ; 
    35                           ;     3. Microchip's name may not be used to endorse or promote products derived from th
      +                          is
    36                           ;        software without specific prior written permission.
    37                           ; 
    38                           ; THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
    39                           ; INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS F
      +                          OR
    40                           ; PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MICROCHIP BE LIABLE FOR ANY DIRECT, INDIREC
      +                          T,
    41                           ; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
    42                           ; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS
    43                           ; INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, ST
      +                          RICT
    44                           ; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE U
      +                          SE OF
    45                           ; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    46                           ; 
    47                           ; 
    48                           ; Code-generator required, PIC16F716 Definitions
    49                           ; 
    50                           ; SFR Addresses
    51  0000                     	;# 
    52  0001                     	;# 
    53  0002                     	;# 
    54  0003                     	;# 
    55  0004                     	;# 
    56  0005                     	;# 
    57  0006                     	;# 
    58  0006                     	;# 
    59  000A                     	;# 
    60  000B                     	;# 
    61  000C                     	;# 
    62  000E                     	;# 
    63  000E                     	;# 
    64  000F                     	;# 
    65  0010                     	;# 
    66  0011                     	;# 
    67  0012                     	;# 
    68  0015                     	;# 
    69  0015                     	;# 
    70  0016                     	;# 
    71  0017                     	;# 
    72  0018                     	;# 
    73  0019                     	;# 
    74  001E                     	;# 
    75  001F                     	;# 
    76  0081                     	;# 
    77  0085                     	;# 
    78  0086                     	;# 
    79  0086                     	;# 
    80  008C                     	;# 
    81  008E                     	;# 
    82  0092                     	;# 
    83  009F                     	;# 
    84  0000                     	;# 
    85  0001                     	;# 
    86  0002                     	;# 
    87  0003                     	;# 
    88  0004                     	;# 
    89  0005                     	;# 
    90  0006                     	;# 
    91  0006                     	;# 
    92  000A                     	;# 
    93  000B                     	;# 
    94  000C                     	;# 
    95  000E                     	;# 
    96  000E                     	;# 
    97  000F                     	;# 
    98  0010                     	;# 
    99  0011                     	;# 
   100  0012                     	;# 
   101  0015                     	;# 
   102  0015                     	;# 
   103  0016                     	;# 
   104  0017                     	;# 
   105  0018                     	;# 
   106  0019                     	;# 
   107  001E                     	;# 
   108  001F                     	;# 
   109  0081                     	;# 
   110  0085                     	;# 
   111  0086                     	;# 
   112  0086                     	;# 
   113  008C                     	;# 
   114  008E                     	;# 
   115  0092                     	;# 
   116  009F                     	;# 
   117  000B                     _INTCONbits	set	11
   118  0010                     _T1CONbits	set	16
   119  0006                     _PORTBbits	set	6
   120  000C                     _PIR1bits	set	12
   121  000E                     _TMR1L	set	14
   122  000F                     _TMR1H	set	15
   123  008C                     _PIE1bits	set	140
   124  0086                     _TRISBbits	set	134
   125                           
   126                           	psect	cinit
   127  0010                     start_initialization:	
   128                           ; #config settings
   129                           
   130  0010                     __initialization:	
   131                           
   132                           ; Clear objects allocated to COMMON
   133  0010  01FB               	clrf	__pbssCOMMON& (0+127)
   134  0011  01FC               	clrf	(__pbssCOMMON+1)& (0+127)
   135  0012  01FD               	clrf	(__pbssCOMMON+2)& (0+127)
   136                           
   137                           ; Clear objects allocated to BANK0
   138  0013  1283               	bcf	3,5	;RP0=0, select bank0
   139  0014  01A0               	clrf	__pbssBANK0& (0+127)
   140  0015  01A1               	clrf	(__pbssBANK0+1)& (0+127)
   141  0016  01A2               	clrf	(__pbssBANK0+2)& (0+127)
   142  0017  01A3               	clrf	(__pbssBANK0+3)& (0+127)
   143  0018  01A4               	clrf	(__pbssBANK0+4)& (0+127)
   144  0019                     end_of_initialization:	
   145                           ;End of C runtime variable initialization code
   146                           
   147  0019                     __end_of__initialization:	
   148  0019  0183               	clrf	3
   149  001A  290E               	ljmp	_main	;jump to C main() function
   150                           
   151                           	psect	bssCOMMON
   152  007B                     __pbssCOMMON:	
   153  007B                     timer1_interrupt_decoder@state_timer:	
   154  007B                     	ds	1
   155  007C                     timer1_interrupt_decoder@bit_count:	
   156  007C                     	ds	1
   157  007D                     _ir_data_valid:	
   158  007D                     	ds	1
   159                           
   160                           	psect	bssBANK0
   161  0020                     __pbssBANK0:	
   162  0020                     _ir_data:	
   163  0020                     	ds	4
   164  0024                     timer1_interrupt_decoder@decoder_state:	
   165  0024                     	ds	1
   166                           
   167                           	psect	cstackCOMMON
   168  0070                     __pcstackCOMMON:	
   169  0070                     ?_timer1_interrupt_decoder:	
   170  0070                     ??_timer1_interrupt_decoder:	
   171                           ; 1 bytes @ 0x0
   172                           
   173  0070                     ?_setup_ir_decoder:	
   174                           ; 1 bytes @ 0x0
   175                           
   176  0070                     ?_isr:	
   177                           ; 1 bytes @ 0x0
   178                           
   179  0070                     ?_main:	
   180                           ; 1 bytes @ 0x0
   181                           
   182                           
   183                           ; 1 bytes @ 0x0
   184  0070                     	ds	7
   185  0077                     ??_isr:	
   186                           
   187                           ; 1 bytes @ 0x7
   188  0077                     	ds	4
   189                           
   190                           	psect	cstackBANK0
   191  0000                     __pcstackBANK0:	
   192  0000                     ??_setup_ir_decoder:	
   193  0000                     ??_main:	
   194                           ; 1 bytes @ 0x0
   195                           
   196                           
   197                           	psect	maintext
   198  010E                     __pmaintext:	
   199                           ; 1 bytes @ 0x0
   200 ;;
   201 ;;Main: autosize = 0, tempsize = 0, incstack = 0, save=0
   202 ;;
   203 ;; *************** function _main *****************
   204 ;; Defined at:
   205 ;;		line 18 in file "main.c"
   206 ;; Parameters:    Size  Location     Type
   207 ;;		None
   208 ;; Auto vars:     Size  Location     Type
   209 ;;		None
   210 ;; Return value:  Size  Location     Type
   211 ;;                  1    wreg      void 
   212 ;; Registers used:
   213 ;;		wreg, status,2, status,0, pclath, cstack
   214 ;; Tracked objects:
   215 ;;		On entry : B00/0
   216 ;;		On exit  : 0/0
   217 ;;		Unchanged: 0/0
   218 ;; Data sizes:     COMMON   BANK0   BANK1
   219 ;;      Params:         0       0       0
   220 ;;      Locals:         0       0       0
   221 ;;      Temps:          0       0       0
   222 ;;      Totals:         0       0       0
   223 ;;Total ram usage:        0 bytes
   224 ;; Hardware stack levels required when called:    3
   225 ;; This function calls:
   226 ;;		_setup_ir_decoder
   227 ;; This function is called by:
   228 ;;		Startup code after reset
   229 ;; This function uses a non-reentrant model
   230 ;;
   231                           
   232                           
   233                           ;psect for function _main
   234  010E                     _main:	
   235                           
   236                           ;main.c: 19: setup_ir_decoder();
   237                           
   238                           ;incstack = 0
   239                           ; Regs used in _main: [wreg+status,2+status,0+pclath+cstack]
   240  010E  20F8               	fcall	_setup_ir_decoder
   241  010F                     l82:	
   242                           ;main.c: 21: for(;;){}
   243                           
   244  010F  290F               	goto	l82
   245  0110                     __end_of_main:	
   246                           
   247                           	psect	text1
   248  00F8                     __ptext1:	
   249 ;; *************** function _setup_ir_decoder *****************
   250 ;; Defined at:
   251 ;;		line 139 in file "ir_decoder.c"
   252 ;; Parameters:    Size  Location     Type
   253 ;;		None
   254 ;; Auto vars:     Size  Location     Type
   255 ;;		None
   256 ;; Return value:  Size  Location     Type
   257 ;;                  1    wreg      void 
   258 ;; Registers used:
   259 ;;		wreg
   260 ;; Tracked objects:
   261 ;;		On entry : 0/0
   262 ;;		On exit  : 0/0
   263 ;;		Unchanged: 0/0
   264 ;; Data sizes:     COMMON   BANK0   BANK1
   265 ;;      Params:         0       0       0
   266 ;;      Locals:         0       0       0
   267 ;;      Temps:          0       0       0
   268 ;;      Totals:         0       0       0
   269 ;;Total ram usage:        0 bytes
   270 ;; Hardware stack levels used:    1
   271 ;; Hardware stack levels required when called:    2
   272 ;; This function calls:
   273 ;;		Nothing
   274 ;; This function is called by:
   275 ;;		_main
   276 ;; This function uses a non-reentrant model
   277 ;;
   278                           
   279                           
   280                           ;psect for function _setup_ir_decoder
   281  00F8                     _setup_ir_decoder:	
   282                           
   283                           ;ir_decoder.c: 141: TRISBbits.TRISB0 = 1;
   284                           
   285                           ;incstack = 0
   286                           ; Regs used in _setup_ir_decoder: [wreg]
   287  00F8  1683               	bsf	3,5	;RP0=1, select bank1
   288  00F9  1406               	bsf	6,0	;volatile
   289                           
   290                           ;ir_decoder.c: 143: T1CONbits.T1OSCEN = 1;
   291  00FA  1283               	bcf	3,5	;RP0=0, select bank0
   292  00FB  1590               	bsf	16,3	;volatile
   293                           
   294                           ;ir_decoder.c: 144: T1CONbits.T1SYNC = 1;
   295  00FC  1510               	bsf	16,2	;volatile
   296                           
   297                           ;ir_decoder.c: 145: T1CONbits.TMR1ON = 1;
   298  00FD  1410               	bsf	16,0	;volatile
   299                           
   300                           ;ir_decoder.c: 146: PIE1bits.TMR1IE = 1;
   301  00FE  1683               	bsf	3,5	;RP0=1, select bank1
   302  00FF  140C               	bsf	12,0	;volatile
   303                           
   304                           ;ir_decoder.c: 147: INTCONbits.PEIE = 1;
   305  0100  170B               	bsf	11,6	;volatile
   306                           
   307                           ;ir_decoder.c: 148: INTCONbits.GIE = 1;
   308  0101  178B               	bsf	11,7	;volatile
   309                           
   310                           ;ir_decoder.c: 149: do { TMR1H = 255; TMR1L = (255-140); PIR1bits.TMR1IF = 0; } while(0)
      +                          ;
   311  0102  30FF               	movlw	255
   312  0103  1283               	bcf	3,5	;RP0=0, select bank0
   313  0104  008F               	movwf	15	;volatile
   314  0105  3073               	movlw	115
   315  0106  008E               	movwf	14	;volatile
   316  0107  100C               	bcf	12,0	;volatile
   317  0108  0008               	return
   318  0109                     __end_of_setup_ir_decoder:	
   319                           
   320                           	psect	text2
   321  00E6                     __ptext2:	
   322 ;; *************** function _isr *****************
   323 ;; Defined at:
   324 ;;		line 12 in file "main.c"
   325 ;; Parameters:    Size  Location     Type
   326 ;;		None
   327 ;; Auto vars:     Size  Location     Type
   328 ;;		None
   329 ;; Return value:  Size  Location     Type
   330 ;;                  1    wreg      void 
   331 ;; Registers used:
   332 ;;		wreg, fsr0l, fsr0h, status,2, status,0, pclath, cstack
   333 ;; Tracked objects:
   334 ;;		On entry : 0/0
   335 ;;		On exit  : 0/0
   336 ;;		Unchanged: 0/0
   337 ;; Data sizes:     COMMON   BANK0   BANK1
   338 ;;      Params:         0       0       0
   339 ;;      Locals:         0       0       0
   340 ;;      Temps:          4       0       0
   341 ;;      Totals:         4       0       0
   342 ;;Total ram usage:        4 bytes
   343 ;; Hardware stack levels used:    1
   344 ;; Hardware stack levels required when called:    1
   345 ;; This function calls:
   346 ;;		_timer1_interrupt_decoder
   347 ;; This function is called by:
   348 ;;		Interrupt level 1
   349 ;; This function uses a non-reentrant model
   350 ;;
   351                           
   352                           
   353                           ;psect for function _isr
   354  00E6                     _isr:	
   355                           
   356                           ;main.c: 13: if (PIR1bits.TMR1IF && PIE1bits.TMR1IE) {
   357  00E6  1C0C               	btfss	12,0	;volatile
   358  00E7  28EC               	goto	i1l77
   359  00E8  1683               	bsf	3,5	;RP0=1, select bank1
   360  00E9  1C0C               	btfss	12,0	;volatile
   361  00EA  28EC               	goto	i1l77
   362                           
   363                           ;main.c: 14: timer1_interrupt_decoder();
   364  00EB  201B               	fcall	_timer1_interrupt_decoder
   365  00EC                     i1l77:	
   366  00EC  087A               	movf	??_isr+3,w
   367  00ED  1283               	bcf	3,5	;RP0=0, select bank0
   368  00EE  00FF               	movwf	127
   369  00EF  0879               	movf	??_isr+2,w
   370  00F0  008A               	movwf	10
   371  00F1  0878               	movf	??_isr+1,w
   372  00F2  0084               	movwf	4
   373  00F3  0E77               	swapf	??_isr^(0+-128),w
   374  00F4  0083               	movwf	3
   375  00F5  0EFE               	swapf	126,f
   376  00F6  0E7E               	swapf	126,w
   377  00F7  0009               	retfie
   378  00F8                     __end_of_isr:	
   379                           
   380                           	psect	intentry
   381  0004                     __pintentry:	
   382                           ;incstack = 0
   383                           ; Regs used in _isr: [wreg-fsr0h+status,2+status,0+pclath+cstack]
   384                           
   385  0004                     interrupt_function:	
   386  007E                     saved_w	set	btemp
   387  0004  00FE               	movwf	btemp
   388  0005  0E03               	swapf	3,w
   389  0006  00F7               	movwf	??_isr
   390  0007  0804               	movf	4,w
   391  0008  00F8               	movwf	??_isr+1
   392  0009  080A               	movf	10,w
   393  000A  00F9               	movwf	??_isr+2
   394  000B  1283               	bcf	3,5	;RP0=0, select bank0
   395  000C  087F               	movf	btemp+1,w
   396  000D  00FA               	movwf	??_isr+3
   397  000E  28E6               	ljmp	_isr
   398                           
   399                           	psect	text3
   400  001B                     __ptext3:	
   401 ;; *************** function _timer1_interrupt_decoder *****************
   402 ;; Defined at:
   403 ;;		line 48 in file "ir_decoder.c"
   404 ;; Parameters:    Size  Location     Type
   405 ;;		None
   406 ;; Auto vars:     Size  Location     Type
   407 ;;		None
   408 ;; Return value:  Size  Location     Type
   409 ;;                  1    wreg      void 
   410 ;; Registers used:
   411 ;;		wreg, fsr0l, fsr0h, status,2, status,0
   412 ;; Tracked objects:
   413 ;;		On entry : 0/0
   414 ;;		On exit  : 0/0
   415 ;;		Unchanged: 0/0
   416 ;; Data sizes:     COMMON   BANK0   BANK1
   417 ;;      Params:         0       0       0
   418 ;;      Locals:         0       0       0
   419 ;;      Temps:          7       0       0
   420 ;;      Totals:         7       0       0
   421 ;;Total ram usage:        7 bytes
   422 ;; Hardware stack levels used:    1
   423 ;; This function calls:
   424 ;;		Nothing
   425 ;; This function is called by:
   426 ;;		_isr
   427 ;; This function uses a non-reentrant model
   428 ;;
   429                           
   430                           
   431                           ;psect for function _timer1_interrupt_decoder
   432  001B                     _timer1_interrupt_decoder:	
   433                           
   434                           ;incstack = 0
   435                           ; Regs used in _timer1_interrupt_decoder: [wreg-fsr0h+status,2+status,0]
   436                           ;ir_decoder.c: 50: static ir_decoder_state_t decoder_state = STATE_IDLE;
   437                           ;ir_decoder.c: 51: static uint8_t bit_count = 0;
   438                           ;ir_decoder.c: 52: static uint8_t state_timer = 0;
   439                           ;ir_decoder.c: 54: do { TMR1H = 255; TMR1L = (255-140); PIR1bits.TMR1IF = 0; } while(0);
   440  001B  30FF               	movlw	255
   441  001C  1283               	bcf	3,5	;RP0=0, select bank0
   442  001D  008F               	movwf	15	;volatile
   443  001E  3073               	movlw	115
   444  001F  008E               	movwf	14	;volatile
   445  0020  100C               	bcf	12,0	;volatile
   446                           
   447                           ;ir_decoder.c: 57: if(ir_data_valid)
   448  0021  087D               	movf	_ir_data_valid,w
   449  0022  1D03               	btfss	3,2
   450  0023  0008               	return
   451  0024  28DA               	goto	i1l696
   452  0025                     i1l34:	
   453                           ;ir_decoder.c: 61: case STATE_IDLE:
   454                           
   455                           ;ir_decoder.c: 60: switch (decoder_state) {
   456                           
   457                           ;ir_decoder.c: 58: return;
   458                           
   459                           
   460                           ;ir_decoder.c: 63: if (PORTBbits.RB0)
   461  0025  1806               	btfsc	6,0	;volatile
   462  0026  0008               	return
   463                           
   464                           ;ir_decoder.c: 65: decoder_state = STATE_START;
   465                           
   466                           ;ir_decoder.c: 64: return;
   467  0027  01A4               	clrf	timer1_interrupt_decoder@decoder_state
   468  0028  0AA4               	incf	timer1_interrupt_decoder@decoder_state,f
   469                           
   470                           ;ir_decoder.c: 66: state_timer = 1;
   471  0029  01FB               	clrf	timer1_interrupt_decoder@state_timer
   472  002A  0AFB               	incf	timer1_interrupt_decoder@state_timer,f
   473                           
   474                           ;ir_decoder.c: 67: bit_count = 0;
   475  002B  01FC               	clrf	timer1_interrupt_decoder@bit_count
   476                           
   477                           ;ir_decoder.c: 68: return;
   478  002C  0008               	return
   479  002D                     i1l36:	
   480                           ;ir_decoder.c: 69: case STATE_START:
   481                           
   482                           
   483                           ;ir_decoder.c: 71: if (!PORTBbits.RB0) {
   484  002D  1806               	btfsc	6,0	;volatile
   485  002E  2834               	goto	i1l616
   486                           
   487                           ;ir_decoder.c: 72: state_timer++;
   488  002F  3001               	movlw	1
   489  0030  00F0               	movwf	??_timer1_interrupt_decoder
   490  0031  0870               	movf	??_timer1_interrupt_decoder,w
   491  0032  07FB               	addwf	timer1_interrupt_decoder@state_timer,f
   492                           
   493                           ;ir_decoder.c: 73: return;
   494  0033  0008               	return
   495  0034                     i1l616:	
   496                           
   497                           ;ir_decoder.c: 74: }
   498                           ;ir_decoder.c: 76: if (((((9000/140)-2) <= ((state_timer))) && (((state_timer)) <= ((900
      +                          0/140)+2)))) {
   499  0034  303E               	movlw	62
   500  0035  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   501  0036  1C03               	skipc
   502  0037  2842               	goto	i1l626
   503  0038  3043               	movlw	67
   504  0039  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   505  003A  1803               	skipnc
   506  003B  2842               	goto	i1l626
   507                           
   508                           ;ir_decoder.c: 77: decoder_state = STATE_START_GAP;
   509  003C  3002               	movlw	2
   510  003D  00F0               	movwf	??_timer1_interrupt_decoder
   511  003E  0870               	movf	??_timer1_interrupt_decoder,w
   512  003F  00A4               	movwf	timer1_interrupt_decoder@decoder_state
   513                           
   514                           ;ir_decoder.c: 78: state_timer=0;
   515  0040  01FB               	clrf	timer1_interrupt_decoder@state_timer
   516                           
   517                           ;ir_decoder.c: 79: return;
   518  0041  0008               	return
   519  0042                     i1l626:	
   520                           
   521                           ;ir_decoder.c: 80: }
   522                           ;ir_decoder.c: 82: decoder_state = STATE_IDLE;
   523  0042  01A4               	clrf	timer1_interrupt_decoder@decoder_state
   524                           
   525                           ;ir_decoder.c: 83: return;
   526  0043  0008               	return
   527  0044                     i1l39:	
   528                           ;ir_decoder.c: 84: case STATE_START_GAP:
   529                           
   530                           
   531                           ;ir_decoder.c: 86: if (PORTBbits.RB0) {
   532  0044  1C06               	btfss	6,0	;volatile
   533  0045  284B               	goto	i1l634
   534                           
   535                           ;ir_decoder.c: 87: state_timer++;
   536  0046  3001               	movlw	1
   537  0047  00F0               	movwf	??_timer1_interrupt_decoder
   538  0048  0870               	movf	??_timer1_interrupt_decoder,w
   539  0049  07FB               	addwf	timer1_interrupt_decoder@state_timer,f
   540                           
   541                           ;ir_decoder.c: 88: return;
   542  004A  0008               	return
   543  004B                     i1l634:	
   544                           
   545                           ;ir_decoder.c: 89: }
   546                           ;ir_decoder.c: 90: if (!((((4500/140)-2) <= ((state_timer))) && (((state_timer)) <= ((45
      +                          00/140)+2)))) {
   547  004B  301E               	movlw	30
   548  004C  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   549  004D  1C03               	skipc
   550  004E  2853               	goto	i1l638
   551  004F  3023               	movlw	35
   552  0050  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   553  0051  1C03               	skipc
   554  0052  2855               	goto	i1l642
   555  0053                     i1l638:	
   556                           
   557                           ;ir_decoder.c: 91: decoder_state = STATE_IDLE;
   558  0053  01A4               	clrf	timer1_interrupt_decoder@decoder_state
   559                           
   560                           ;ir_decoder.c: 92: return;
   561  0054  0008               	return
   562  0055                     i1l642:	
   563                           
   564                           ;ir_decoder.c: 93: }
   565                           ;ir_decoder.c: 95: state_timer = 0;
   566  0055  01FB               	clrf	timer1_interrupt_decoder@state_timer
   567                           
   568                           ;ir_decoder.c: 96: decoder_state = STATE_BURST;
   569  0056  3003               	movlw	3
   570  0057  00F0               	movwf	??_timer1_interrupt_decoder
   571  0058  0870               	movf	??_timer1_interrupt_decoder,w
   572  0059  00A4               	movwf	timer1_interrupt_decoder@decoder_state
   573                           
   574                           ;ir_decoder.c: 97: return;
   575  005A  0008               	return
   576  005B                     i1l44:	
   577                           ;ir_decoder.c: 98: case STATE_BURST:
   578                           
   579                           
   580                           ;ir_decoder.c: 99: if (!PORTBbits.RB0) {
   581  005B  1806               	btfsc	6,0	;volatile
   582  005C  2862               	goto	i1l652
   583                           
   584                           ;ir_decoder.c: 100: state_timer++;
   585  005D  3001               	movlw	1
   586  005E  00F0               	movwf	??_timer1_interrupt_decoder
   587  005F  0870               	movf	??_timer1_interrupt_decoder,w
   588  0060  07FB               	addwf	timer1_interrupt_decoder@state_timer,f
   589                           
   590                           ;ir_decoder.c: 101: return;
   591  0061  0008               	return
   592  0062                     i1l652:	
   593                           
   594                           ;ir_decoder.c: 102: }
   595                           ;ir_decoder.c: 104: if (!((((562/140)-2) <= ((state_timer))) && (((state_timer)) <= ((56
      +                          2/140)+2)))) {
   596  0062  3002               	movlw	2
   597  0063  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   598  0064  1C03               	skipc
   599  0065  286A               	goto	i1l656
   600  0066  3007               	movlw	7
   601  0067  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   602  0068  1C03               	skipc
   603  0069  286C               	goto	i1l658
   604  006A                     i1l656:	
   605                           
   606                           ;ir_decoder.c: 105: decoder_state = STATE_IDLE;
   607  006A  01A4               	clrf	timer1_interrupt_decoder@decoder_state
   608                           
   609                           ;ir_decoder.c: 106: } else {
   610  006B  0008               	return
   611  006C                     i1l658:	
   612                           
   613                           ;ir_decoder.c: 107: decoder_state = STATE_GAP;
   614  006C  3004               	movlw	4
   615  006D  00F0               	movwf	??_timer1_interrupt_decoder
   616  006E  0870               	movf	??_timer1_interrupt_decoder,w
   617  006F  00A4               	movwf	timer1_interrupt_decoder@decoder_state
   618                           
   619                           ;ir_decoder.c: 108: state_timer = 0;
   620  0070  01FB               	clrf	timer1_interrupt_decoder@state_timer
   621                           
   622                           ;ir_decoder.c: 109: }
   623                           ;ir_decoder.c: 110: return;
   624  0071  0008               	return
   625  0072                     i1l50:	
   626                           ;ir_decoder.c: 111: case STATE_GAP:
   627                           
   628                           
   629                           ;ir_decoder.c: 112: if (PORTBbits.RB0) {
   630  0072  1C06               	btfss	6,0	;volatile
   631  0073  2879               	goto	i1l668
   632                           
   633                           ;ir_decoder.c: 113: state_timer++;
   634  0074  3001               	movlw	1
   635  0075  00F0               	movwf	??_timer1_interrupt_decoder
   636  0076  0870               	movf	??_timer1_interrupt_decoder,w
   637  0077  07FB               	addwf	timer1_interrupt_decoder@state_timer,f
   638                           
   639                           ;ir_decoder.c: 114: return;
   640  0078  0008               	return
   641  0079                     i1l668:	
   642                           
   643                           ;ir_decoder.c: 115: }
   644                           ;ir_decoder.c: 116: if (((((562/140)-2) <= ((state_timer))) && (((state_timer)) <= ((562
      +                          /140)+2)))) {
   645  0079  3002               	movlw	2
   646  007A  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   647  007B  1C03               	skipc
   648  007C  28A1               	goto	i1l674
   649  007D  3007               	movlw	7
   650  007E  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   651  007F  1803               	skipnc
   652  0080  28A1               	goto	i1l674
   653                           
   654                           ;ir_decoder.c: 118: ir_data &= ~(1u << (31u-bit_count));
   655  0081  037C               	decf	timer1_interrupt_decoder@bit_count,w
   656  0082  3AFF               	xorlw	255
   657  0083  3E1F               	addlw	31
   658  0084  00F0               	movwf	??_timer1_interrupt_decoder
   659  0085  0AF0               	incf	??_timer1_interrupt_decoder,f
   660  0086  3001               	movlw	1
   661  0087  00F1               	movwf	??_timer1_interrupt_decoder+1
   662  0088  3000               	movlw	0
   663  0089  00F2               	movwf	??_timer1_interrupt_decoder+2
   664  008A  288E               	goto	u36_24
   665  008B                     u36_25:	
   666  008B  1003               	clrc
   667  008C  0DF1               	rlf	??_timer1_interrupt_decoder+1,f
   668  008D  0DF2               	rlf	??_timer1_interrupt_decoder+2,f
   669  008E                     u36_24:	
   670  008E  0BF0               	decfsz	??_timer1_interrupt_decoder,f
   671  008F  288B               	goto	u36_25
   672  0090  09F1               	comf	??_timer1_interrupt_decoder+1,f
   673  0091  09F2               	comf	??_timer1_interrupt_decoder+2,f
   674  0092  0871               	movf	??_timer1_interrupt_decoder+1,w
   675  0093  00F3               	movwf	??_timer1_interrupt_decoder+3
   676  0094  0872               	movf	??_timer1_interrupt_decoder+2,w
   677  0095  00F4               	movwf	??_timer1_interrupt_decoder+4
   678  0096  01F5               	clrf	??_timer1_interrupt_decoder+5
   679  0097  01F6               	clrf	??_timer1_interrupt_decoder+6
   680  0098  0873               	movf	??_timer1_interrupt_decoder+3,w
   681  0099  05A0               	andwf	_ir_data,f
   682  009A  0874               	movf	??_timer1_interrupt_decoder+4,w
   683  009B  05A1               	andwf	_ir_data+1,f
   684  009C  0875               	movf	??_timer1_interrupt_decoder+5,w
   685  009D  05A2               	andwf	_ir_data+2,f
   686  009E  0876               	movf	??_timer1_interrupt_decoder+6,w
   687  009F  05A3               	andwf	_ir_data+3,f
   688                           
   689                           ;ir_decoder.c: 119: } else if (((((1675/140)-2) <= ((state_timer))) && (((state_timer)) 
      +                          <= ((1675/140)+2)))) {
   690  00A0  28C9               	goto	i1l684
   691  00A1                     i1l674:	
   692  00A1  3009               	movlw	9
   693  00A2  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   694  00A3  1C03               	skipc
   695  00A4  28C7               	goto	i1l680
   696  00A5  300E               	movlw	14
   697  00A6  027B               	subwf	timer1_interrupt_decoder@state_timer,w
   698  00A7  1803               	skipnc
   699  00A8  28C7               	goto	i1l680
   700                           
   701                           ;ir_decoder.c: 121: ir_data |= (1u << (31u-bit_count));
   702  00A9  037C               	decf	timer1_interrupt_decoder@bit_count,w
   703  00AA  3AFF               	xorlw	255
   704  00AB  3E1F               	addlw	31
   705  00AC  00F0               	movwf	??_timer1_interrupt_decoder
   706  00AD  0AF0               	incf	??_timer1_interrupt_decoder,f
   707  00AE  3001               	movlw	1
   708  00AF  00F1               	movwf	??_timer1_interrupt_decoder+1
   709  00B0  3000               	movlw	0
   710  00B1  00F2               	movwf	??_timer1_interrupt_decoder+2
   711  00B2  28B6               	goto	u39_24
   712  00B3                     u39_25:	
   713  00B3  1003               	clrc
   714  00B4  0DF1               	rlf	??_timer1_interrupt_decoder+1,f
   715  00B5  0DF2               	rlf	??_timer1_interrupt_decoder+2,f
   716  00B6                     u39_24:	
   717  00B6  0BF0               	decfsz	??_timer1_interrupt_decoder,f
   718  00B7  28B3               	goto	u39_25
   719  00B8  0871               	movf	??_timer1_interrupt_decoder+1,w
   720  00B9  00F3               	movwf	??_timer1_interrupt_decoder+3
   721  00BA  0872               	movf	??_timer1_interrupt_decoder+2,w
   722  00BB  00F4               	movwf	??_timer1_interrupt_decoder+4
   723  00BC  01F5               	clrf	??_timer1_interrupt_decoder+5
   724  00BD  01F6               	clrf	??_timer1_interrupt_decoder+6
   725  00BE  0873               	movf	??_timer1_interrupt_decoder+3,w
   726  00BF  04A0               	iorwf	_ir_data,f
   727  00C0  0874               	movf	??_timer1_interrupt_decoder+4,w
   728  00C1  04A1               	iorwf	_ir_data+1,f
   729  00C2  0875               	movf	??_timer1_interrupt_decoder+5,w
   730  00C3  04A2               	iorwf	_ir_data+2,f
   731  00C4  0876               	movf	??_timer1_interrupt_decoder+6,w
   732  00C5  04A3               	iorwf	_ir_data+3,f
   733                           
   734                           ;ir_decoder.c: 122: } else {
   735  00C6  28C9               	goto	i1l684
   736  00C7                     i1l680:	
   737                           
   738                           ;ir_decoder.c: 124: decoder_state = STATE_IDLE;
   739  00C7  01A4               	clrf	timer1_interrupt_decoder@decoder_state
   740                           
   741                           ;ir_decoder.c: 125: return;
   742  00C8  0008               	return
   743  00C9                     i1l684:	
   744                           
   745                           ;ir_decoder.c: 126: }
   746                           ;ir_decoder.c: 128: bit_count++;
   747  00C9  3001               	movlw	1
   748  00CA  00F0               	movwf	??_timer1_interrupt_decoder
   749  00CB  0870               	movf	??_timer1_interrupt_decoder,w
   750  00CC  07FC               	addwf	timer1_interrupt_decoder@bit_count,f
   751                           
   752                           ;ir_decoder.c: 129: if (bit_count == 32) {
   753  00CD  3020               	movlw	32
   754  00CE  067C               	xorwf	timer1_interrupt_decoder@bit_count,w
   755  00CF  1D03               	btfss	3,2
   756  00D0  28D5               	goto	i1l690
   757                           
   758                           ;ir_decoder.c: 130: ir_data_valid = 1;
   759  00D1  01FD               	clrf	_ir_data_valid
   760  00D2  0AFD               	incf	_ir_data_valid,f
   761                           
   762                           ;ir_decoder.c: 131: decoder_state = STATE_IDLE;
   763  00D3  01A4               	clrf	timer1_interrupt_decoder@decoder_state
   764                           
   765                           ;ir_decoder.c: 132: } else {
   766  00D4  0008               	return
   767  00D5                     i1l690:	
   768                           
   769                           ;ir_decoder.c: 133: decoder_state = STATE_BURST;
   770  00D5  3003               	movlw	3
   771  00D6  00F0               	movwf	??_timer1_interrupt_decoder
   772  00D7  0870               	movf	??_timer1_interrupt_decoder,w
   773  00D8  00A4               	movwf	timer1_interrupt_decoder@decoder_state
   774                           
   775                           ;ir_decoder.c: 136: }
   776                           
   777                           ;ir_decoder.c: 134: }
   778                           ;ir_decoder.c: 135: return;
   779  00D9  0008               	return
   780  00DA                     i1l696:	
   781  00DA  0824               	movf	timer1_interrupt_decoder@decoder_state,w
   782                           
   783                           ; Switch size 1, requested type "space"
   784                           ; Number of cases is 5, Range of values is 0 to 4
   785                           ; switch strategies available:
   786                           ; Name         Instructions Cycles
   787                           ; direct_byte           11     6 (fixed)
   788                           ; simple_byte           16     9 (average)
   789                           ; jumptable            260     6 (fixed)
   790                           ;	Chosen strategy is direct_byte
   791  00DB  0084               	movwf	4
   792  00DC  3005               	movlw	5
   793  00DD  0204               	subwf	4,w
   794  00DE  1803               	skipnc
   795  00DF  0008               	return
   796  00E0  3001               	movlw	high i1S736
   797  00E1  008A               	movwf	10
   798  00E2  3009               	movlw	low i1S736
   799  00E3  0704               	addwf	4,w
   800  00E4  0082               	movwf	2
   801  00E5  0008               	return
   802  00E6                     __end_of_timer1_interrupt_decoder:	
   803  007E                     btemp	set	126	;btemp
   804  007E                     wtemp0	set	126
   805                           
   806                           	psect	swtext1
   807  0109                     __pswtext1:	
   808  0109                     i1S736:	
   809  0109  2825               	ljmp	i1l34
   810  010A  282D               	ljmp	i1l36
   811  010B  2844               	ljmp	i1l39
   812  010C  285B               	ljmp	i1l44
   813  010D  2872               	ljmp	i1l50


Data Sizes:
    Strings     0
    Constant    0
    Data        0
    BSS         8
    Persistent  0
    Stack       0

Auto Spaces:
    Space          Size  Autos    Used
    COMMON           14     11      14
    BANK0            80      0       5
    BANK1            32      0       0

Pointer List with Targets:

    None.

Critical Paths under _main in COMMON

    None.

Critical Paths under _isr in COMMON

    _isr->_timer1_interrupt_decoder

Critical Paths under _main in BANK0

    None.

Critical Paths under _isr in BANK0

    None.

Critical Paths under _main in BANK1

    None.

Critical Paths under _isr in BANK1

    None.

Call Graph Tables:

 ---------------------------------------------------------------------------------
 (Depth) Function   	        Calls       Base Space   Used Autos Params    Refs
 ---------------------------------------------------------------------------------
 (0) _main                                                 0     0      0       0
                   _setup_ir_decoder
 ---------------------------------------------------------------------------------
 (1) _setup_ir_decoder                                     0     0      0       0
 ---------------------------------------------------------------------------------
 Estimated maximum stack depth 1
 ---------------------------------------------------------------------------------
 (Depth) Function   	        Calls       Base Space   Used Autos Params    Refs
 ---------------------------------------------------------------------------------
 (2) _isr                                                  4     4      0       0
                                              7 COMMON     4     4      0
           _timer1_interrupt_decoder
 ---------------------------------------------------------------------------------
 (3) _timer1_interrupt_decoder                             7     7      0       0
                                              0 COMMON     7     7      0
 ---------------------------------------------------------------------------------
 Estimated maximum stack depth 3
 ---------------------------------------------------------------------------------

 Call Graph Graphs:

 _main (ROOT)
   _setup_ir_decoder

 _isr (ROOT)
   _timer1_interrupt_decoder

 Address spaces:
Name               Size   Autos  Total    Cost      Usage
BITCOMMON            E      0       0       0        0.0%
NULL                 0      0       0       0        0.0%
CODE                 0      0       0       0        0.0%
COMMON               E      B       E       1      100.0%
BITSFR0              0      0       0       1        0.0%
SFR0                 0      0       0       1        0.0%
BITSFR1              0      0       0       2        0.0%
SFR1                 0      0       0       2        0.0%
STACK                0      0       0       2        0.0%
BITBANK0            50      0       0       3        0.0%
BANK0               50      0       5       4        6.2%
BANK1               20      0       0       5        0.0%
ABS                  0      0      13       6        0.0%
BITBANK1            20      0       0       7        0.0%
DATA                 0      0      13       8        0.0%


Microchip Technology PIC Macro Assembler V1.45 build -152302408 
Symbol Table                                                                                   Tue May 15 04:05:04 2018

             _timer1_interrupt_decoder 001B                                      pc 0002  
                                   l82 010F                                     fsr 0004  
                                  _isr 00E6                                    fsr0 0004  
                                 ?_isr 0070                                   i1l50 0072  
                                 i1l34 0025                                   i1l44 005B  
                                 i1l36 002D                                   i1l39 0044  
                                 i1l77 00EC  timer1_interrupt_decoder@decoder_state 0024  
                                 _main 010E                                   btemp 007E  
                                 start 000F                                  ??_isr 0077  
                                ?_main 0070                                  i1S736 0109  
                                i1l616 0034                                  i1l642 0055  
                                i1l634 004B                                  i1l626 0042  
                                i1l652 0062                                  i1l638 0053  
                                i1l680 00C7                                  i1l656 006A  
                                i1l690 00D5                                  i1l674 00A1  
                                i1l658 006C                                  i1l684 00C9  
                                i1l668 0079                                  i1l696 00DA  
                                _TMR1H 000F                                  _TMR1L 000E  
                                u36_24 008E                                  u36_25 008B  
                                u39_24 00B6                                  u39_25 00B3  
                                pclath 000A                                  status 0003  
                                wtemp0 007E                        __initialization 0010  
                         __end_of_main 0110                                 ??_main 0000  
                        _ir_data_valid 007D              __size_of_setup_ir_decoder 0011  
                               saved_w 007E             ??_timer1_interrupt_decoder 0070  
              __end_of__initialization 0019                         __pcstackCOMMON 0070  
                           __pbssBANK0 0020                             __pmaintext 010E  
                           __pintentry 0004                       _setup_ir_decoder 00F8  
    timer1_interrupt_decoder@bit_count 007C                                __ptext1 00F8  
                              __ptext2 00E6                                __ptext3 001B  
                            _T1CONbits 0010                                _ir_data 0020  
                         __size_of_isr 0012                   end_of_initialization 0019  
     __end_of_timer1_interrupt_decoder 00E6                              _PORTBbits 0006  
                            _TRISBbits 0086                    start_initialization 0010  
                          __end_of_isr 00F8    timer1_interrupt_decoder@state_timer 007B  
    __size_of_timer1_interrupt_decoder 00CB              ?_timer1_interrupt_decoder 0070  
             __end_of_setup_ir_decoder 0109                            __pbssCOMMON 007B  
                            ___latbits 0000                          __pcstackBANK0 0000  
                            __pswtext1 0109                      interrupt_function 0004  
                             _PIE1bits 008C                               _PIR1bits 000C  
                        __size_of_main 0002                      ?_setup_ir_decoder 0070  
                           _INTCONbits 000B                     ??_setup_ir_decoder 0000  
                             intlevel1 0000  
